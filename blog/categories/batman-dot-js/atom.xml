<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Batman.js | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/batman-dot-js/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2014-08-02T14:41:33-07:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Computed Properties: Batman.js and Ember.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/08/02/computed-properties-batman-dot-js-and-ember-dot-js/"/>
    <updated>2014-08-02T09:38:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/08/02/computed-properties-batman-dot-js-and-ember-dot-js</id>
    <content type="html"><![CDATA[<p><a href="http://batmanjs.org">Batman.js</a> is a front-end MVC framework with an unrivaled implementation of key-value observing. I will explore computed properties in batman.js by contrasting them with Ember.js&rsquo;s computed properties.</p>

<!-- more -->


<p>First, disclaimers!</p>

<ul>
<li>I didn&rsquo;t write any of the <code>Batman.Property</code> code that makes this feature possible. I&rsquo;m only a fanboy!</li>
<li>I don&rsquo;t know Ember.js. I&rsquo;ve just gathered examples from the <a href="http://emberjs.com/guides">Ember Guides</a>.</li>
</ul>


<p>To explore computed properties, let&rsquo;s take the <strong>canonical <code>fullName</code> example</strong>. It:</p>

<ul>
<li>depends on two other properties, <code>firstName</code> and <code>lastName</code></li>
<li>returns a string that joins <code>firstName</code> and <code>lastName</code> with a space</li>
<li>can be set</li>
<li>sets <code>firstName</code> and <code>lastName</code> by splitting on whitespace</li>
</ul>


<p>We&rsquo;ll also explore an <strong>aggregrated <code>roster</code> property</strong> which:</p>

<ul>
<li>depends on <code>fullName</code> for each person</li>
<li>joins <code>fullName</code> with <code>,</code></li>
</ul>


<h2>fullName in Ember.js</h2>

<p>(This is yanked wholesale from the <a href="http://emberjs.com/guides/object-model/computed-properties/">Computed Properties Guide</a>.)</p>

<p>A couple of things to notice:</p>

<ul>
<li><code>fullName</code> is defined as <em>one function</em> which handles <code>get</code> and <code>set</code> operations.</li>
<li><code>fullName</code> must be told what properties it depends on.</li>
</ul>


<p>```javascript
App.Person = Ember.Object.extend({
  firstName: null, // These aren&rsquo;t necessary, they&rsquo;re
  lastName: null,  // just for clarity.</p>

<p>  fullName: function(key, value, previousValue) {</p>

<pre><code>// setter
if (arguments.length &gt; 1) {
  var nameParts = value.split(/\s+/);
  this.set('firstName', nameParts[0]);
  this.set('lastName',  nameParts[1]);
}

// getter, also the return value is cached
return this.get('firstName') + ' ' + this.get('lastName');
</code></pre>

<p>  }.property(&lsquo;firstName&rsquo;, &lsquo;lastName&rsquo;)
});
```</p>

<p>Usage is pretty standard: use <code>get</code> and <code>set</code> to access properties.</p>

<p><code>javascript
var captainAmerica = App.Person.create();
captainAmerica.set('fullName', "William Burnside");
captainAmerica.get('firstName'); // William
captainAmerica.get('lastName');  // Burnside
</code></p>

<h2>fullName in Batman.js</h2>

<p>Two things to notice:</p>

<ul>
<li><code>get</code> and <code>set</code> operations are defined <em>separately</em>.</li>
<li><code>fullName</code> doesn&rsquo;t have to be told what its dependencies are.</li>
</ul>


<p>```coffeescript
class App.Person extends Batman.Object
  @accessor &lsquo;firstName&rsquo; # not necessary,
  @accessor &lsquo;lastName&rsquo;  # just here for clarity</p>

<p>  @accessor &lsquo;fullName&rsquo;,</p>

<pre><code>get: (key) -&gt; "#{@get('firstName')} #{@get('lastName')}"
set: (key, value) -&gt;
  nameParts = value.split(/\s+/)
  @set('firstName', nameParts[0])
  @set('lastName', nameParts[1])
  return value # should return newly-set value, although the `get` function will be used for caching.
</code></pre>

<p>```</p>

<p>The usage is almost identical:</p>

<p><code>coffeescript
captainAmerica = new App.Person
captainAmerica.set('fullName', 'William Burnside')
captainAmerica.get('firstName') # William
captainAmerica.get('lastName')  # Burnside
</code></p>

<h2>roster in Ember.js</h2>

<p>(This was adapted from the <a href="http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/">Computed Properties and Aggregate Data Guide</a>.)</p>

<p>Some things stood out to me:</p>

<ul>
<li><code>roster</code>&rsquo;s properties are declared with a DSL. Array dependencies are limited to one layer deep (ie, you can&rsquo;t use <code>@each</code> twice).</li>
<li><code>mapBy</code> is provided by <code>Ember.Enumerable</code> to handle arrays of objects. Nice!</li>
</ul>


<p>```javascript
App.PeopleController = Ember.Controller.extend({
  people: [</p>

<pre><code>App.Person.create({firstName: "Tom", lastName: "Dale"}),
App.Person.create({firstName: "Yehuda", lastName: "Katz"})
</code></pre>

<p>  ],</p>

<p>  roster: function() {</p>

<pre><code>var people = this.get('people');
return people.mapBy('fullName').join(', ');
</code></pre>

<p>  }.property(&lsquo;<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#112;&#101;&#x6f;&#x70;&#108;&#x65;&#x2e;&#64;&#x65;&#x61;&#x63;&#x68;&#46;&#x66;&#x75;&#108;&#108;&#x4e;&#x61;&#109;&#x65;">&#112;&#101;&#111;&#112;&#x6c;&#x65;&#x2e;&#64;&#x65;&#97;&#x63;&#x68;&#46;&#102;&#117;&#x6c;&#108;&#78;&#97;&#x6d;&#x65;</a>&rsquo;)
});
```</p>

<h2>roster in Batman.js</h2>

<p>Here&rsquo;s the analogous construction in batman.js:</p>

<p>```coffeescript
class App.PeopleController extends Batman.Controller
  @accessor &lsquo;people&rsquo;, &ndash;></p>

<pre><code>new Batman.Set([ # this is future-code: constructor will take an array in v0.17.0
  new App.Person(firstName: "Tom", lastName: "Dale")
  new App.Person(firstName: "Yehuda", lastName: "Katz")
])
</code></pre>

<p>  @accessor &lsquo;roster&rsquo;, &ndash;></p>

<pre><code>@get('people').mapToProperty('fullName').join(', ')
</code></pre>

<p>```</p>

<p>One thing is the same:</p>

<ul>
<li><code>mapToProperty</code> works like <code>mapBy</code></li>
</ul>


<p>You might notice two big differences:</p>

<ul>
<li><code>people</code> is a <code>Batman.Set</code> instead of a native Array.</li>
<li><code>roster</code> didn&rsquo;t have to be told what its dependencies are</li>
</ul>


<p>By using batman.js data structures inside <code>@accessor</code> functions, we benefit from batman.js&rsquo;s <a href="http://rmosolgo.github.io/blog/2014/04/20/automatic-source-tracking-in-batman-dot-js/">automatic source tracking</a>. It looks like automatic source tracking was considered by the Ember core team, but deemed <a href="https://github.com/emberjs/ember.js/issues/269#issuecomment-3178319">impossible</a> or <a href="https://github.com/emberjs/ember.js/issues/386#issuecomment-3523589">prohibitively expensive</a>.</p>

<p>I recently saw a quote in a <a href="https://www.youtube.com/watch?v=-DX3vJiqxm4">React.js talk</a>:</p>

<blockquote><p>Intellectuals solve probelms. Geniuses prevent them. &ndash; Albert Einstein</p></blockquote>

<p>I think that&rsquo;s just what the Shopify team did when they implemented <code>Batman.Observable</code>! The API is very simple and it Just Works<sup>TM</sup>.</p>

<h2>My Opinion</h2>

<p><strong>Pros of batman.js:</strong></p>

<ul>
<li>Elegant <code>@accessor</code> API for getters and setters: define <code>get</code> and <code>set</code> separately instead of testing for arguments.</li>
<li>Automatic dependency tracking: batman.js knows what objects &amp; properties were accessed during computation and observes accordingly.</li>
<li>There&rsquo;s no limit to the depth of enumerable dependencies. Any property of a <code>Batman.Object</code> that&rsquo;s accessed will be tracked, no matter where it exists in the app.</li>
</ul>


<p>In fact, <code>@accessor</code> is the heart and soul of a batman.js app. You&rsquo;re basically declaring a system of computed properties, then updating that system from user input. Batman.js propagates information to wherever it needs to be.</p>

<p><strong>Cons of batman.js:</strong></p>

<ul>
<li>&ldquo;It&rsquo;s just not Ember.&rdquo; You miss out on huge user base, corporate support, and everything that goes with that.</li>
<li>Beyond that, batman.js resources are sparse. The <a href="http://batmanjs.org/docs/index.html">new guides</a>, <a href="https://www.softcover.io/read/b5c051f3/batmanjs_mvc_cookbook">cookbook</a> and <a href="http://batmanjs.org/docs/index.html">API docs</a> are improving every week, but for advanced usage you still have to sourcedive sometimes.</li>
<li>There <strong>is</strong> a performance hit for global observability. The only place I&rsquo;ve noticed it is with complex iteration views (<a href="https://github.com/batmanjs/batman/issues/1086">batmanjs/batman#1086</a>). I&rsquo;m hoping to tackle this soon since it&rsquo;s becoming an issue in <a href="http://get.planningcenteronline.com/check-ins">PCO Check-ins</a>.</li>
</ul>


<p>I&rsquo;m not aware of any features missing from batman.js, but I do miss the &ldquo;googleability&rdquo; of a well-traveled path. Batman.js also lacks some of the dev tools like a decent Chrome extension and a command-line client.</p>

<p>I always want to know <em>how</em> things works, so getting in the source is actually a benefit for me.</p>

<p><strong>Six of one, half-dozen of the other:</strong></p>

<ul>
<li>Dependency DSL vs <code>Batman.{DataStructure}</code></li>
<li>Calling super: <code>this._super</code> vs. <code>@wrapAccessor</code></li>
<li>External API with <code>get</code> and <code>set</code></li>
<li>Cached values in computed properties</li>
<li>In batman.js, you can opt out of tracking with <code>Batman.Property.withoutTracking</code>. It&rsquo;s obscure, but I think it&rsquo;s ok because batman.js always covers the more common case.</li>
</ul>


<p>One thing that I found in neither framework was rate-limited properties, a la Knockout. I&rsquo;d love to have a built-in option for this in batman.js.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Handlers in Batman.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/07/28/event-handlers-in-batman-dot-js/"/>
    <updated>2014-07-28T13:23:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/07/28/event-handlers-in-batman-dot-js</id>
    <content type="html"><![CDATA[<p>In <a href="http://batmanjs.org">batman.js</a>, event handlers respond to user interactions like &ldquo;click&rdquo; and &ldquo;submit&rdquo;. You can use them to modify application state in response to those interactions.</p>

<!-- more -->


<p>Let&rsquo;s look at:</p>

<ul>
<li>What event handlers are and where they&rsquo;re defined</li>
<li>How you can connect handlers to DOM events</li>
<li>How you can pass arguments to event handlers</li>
<li>What <code>@</code> refers to inside event handlers</li>
</ul>


<h2>What Are Event Handlers?</h2>

<p>In short, an <em>event handler</em> can be <em>any function inside the render context</em>.</p>

<p>Usually, this means it&rsquo;s a prototype function on a view:</p>

<p><code>coffeescript
class MyApp.ItemsIndexView extends Batman.View
  myEventHandler: -&gt; # handle some event
</code></p>

<p>or, it&rsquo;s a prototype function on a controller:</p>

<p><code>coffeescript
class MyApp.ItemsController extends MyApp.ApplicationController
  myEventHandler: -&gt; # handle some event
</code></p>

<p>Since the main <code>MyApp</code> is also inside the render context, you can also use class functions on the app as event handlers:</p>

<p><code>coffeescript
class window.MyApp extends Batman.App
  @myEventHandler: -&gt; # handle some event
</code></p>

<p><strong>All</strong> of those functions are fair game to be wired up as event handlers.</p>

<h2>Hooking up Event Handlers</h2>

<p>To connect a function to a DOM event, use the <code>data-event</code> binding. You can bind to pretty much any event (I don&rsquo;t know of one that you <em>can&rsquo;t</em> bind to).</p>

<p>The binding takes the form:</p>

<p><code>coffeescript
"data-bind-#{eventName}='#{handlerName}'"
</code></p>

<p>For example, to bind a <code>click</code> event to <code>myEventHandler</code> on this <code>&lt;button&gt;</code>:</p>

<p><code>html
&lt;button data-event-click='myEventHandler'&gt;Click Me&lt;/button&gt;
</code></p>

<p>You can also bind to the <code>submit</code> event of a <code>&lt;form&gt;</code>:</p>

<p><code>html
&lt;form data-event-submit='saveData'&gt;
  &lt;input type='submit'&gt;Save&lt;/input&gt;
&lt;/form&gt;
</code></p>

<h2>Arguments in Event Handlers</h2>

<p>Event handlers have two sets of arguments:</p>

<ul>
<li>arguments that you pass in via <code>withArguments</code> filters</li>
<li>arguments that are automatically passed in by batman.js</li>
</ul>


<h3>Custom Arguments with &ldquo;withArguments&rdquo;</h3>

<p>You can choose some values to pass in with a <code>withArguments</code> filter in your binding.</p>

<p>Consider this event handler:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName)
</code></pre>

<p>```</p>

<p>I could call this with an <code>item</code> by using a <code>withArguments</code> filter:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item'>Alert!</button>
```</p>

<p>You can pass multiple arguments with <code>withArgument</code> by separating them with commas.</p>

<p>For example, if I want more flexible alerts, I could redefine the event handler to take <em>two</em> arguments:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item, punctuation) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName + punctuation)
</code></pre>

<p>```</p>

<p>Then, pass <em>two</em> arguments into it, separated with <code>,</code>:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item, "!" '>Alert!</button>
<button data-event-click='alertItemName | withArguments item, "?" '>Alert?</button>
<button data-event-click='alertItemName | withArguments item, "." '>Alert.</button>
```</p>

<p><strong>Note</strong> that you <strong>must</strong> provide both arguments to the handler. If you don&rsquo;t, batman.js&rsquo;s automatic arguments will take the place of the missing argument!</p>

<h3>Automatic Arguments</h3>

<p>When batman.js invokes an event handler, it <strong>automatically passes in</strong> a few arguments. Here&rsquo;s a handler that uses the automatic arguments:</p>

<p><code>coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  myEventHandler: (node, event, view) -&gt;
</code></p>

<p>It&rsquo;s invoked with:</p>

<ul>
<li><code>node</code>: the DOM node where the event was triggered. For example, a <code>&lt;button&gt;</code>. If you use the same event handler on different nodes, this value will be different.</li>
<li><code>event</code>: The event object for the event.  If you&rsquo;re using <code>batman.jquery</code>, it&rsquo;s the jQuery event object. It contains meta-information about the event.</li>
<li><code>view</code>: The nearest <code>Batman.View</code> instance to <code>node</code>.</li>
</ul>


<h3>Combining Custom and Automatic Arguments</h3>

<p>You can combine custom and automatic arguments. Simply define a handler whose <strong>last three</strong> arguments are the batman.js automatic arguments:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item, punctuation, node, event, view) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName + punctuation)
</code></pre>

<p>```</p>

<p>And use <code>withArguments</code> to pass arguments to the function. You <strong>must</strong> pass the <strong>same number</strong> of arguments. For example:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item, "!"'>Alert!</button></p>

<!-- note the empty string, "" -->


<p><button data-event-click='alertItemName | withArguments item, ""'>Alert</button>
```</p>

<p>When batman.js passes arguments to the function, it simply merges the <code>withArguments</code> array with its automatic array. So, if your <code>withArguments</code> array is too short, you won&rsquo;t get the same results.</p>

<h2><code>@</code> in Event Handlers</h2>

<p>When batman.js dispatches an event handler, it looks up the base object <em>where that handler is defined</em>. Then, it uses that object as <code>@</code> inside the handler.</p>

<p>For example, consider two event handlers. One is defined on a view:</p>

<p>```coffeescript
class MyApp.ItemsIndexView extends Batman.View
  eventHandlerOne: &ndash;></p>

<pre><code>console.log(@) # =&gt; will be the ItemsIndexView instance
</code></pre>

<p>```</p>

<p>The other is defined on a controller:</p>

<p>```coffeescript
class MyApp.ItemsController extends App.ApplicationController
  eventHandlerTwo: &ndash;></p>

<pre><code>console.log(@) # =&gt; will be the ItemsController instance
</code></pre>

<p>```</p>

<p>If you were to hook up those event handlers to buttons:</p>

<p><code>html
&lt;button data-event-click='eventHandlerOne'&gt;&lt;/button&gt;
&lt;button data-event-click='eventHandlerTwo'&gt;&lt;/button&gt;
</code></p>

<p>then click the buttons, you would see the <code>ItemsIndexView</code> object and the <code>ItemsController</code> object in your console:</p>

<p><code>javascript
ItemsIndexView {bindings: Array[7], subviews: Set, _batman: _Batman, viewClass: function, source: "events/index"…}
ItemsController {redirect: function, handleError: function, errorHandler: function, _batman: _Batman, _actionFrames: Array[0]…}
</code></p>

<p>Since batman.js looks up the base object, event handlers behave just like normal functions in the place you define them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Batman.js and Devise]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/07/21/batman-dot-js-and-devise/"/>
    <updated>2014-07-21T09:08:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/07/21/batman-dot-js-and-devise</id>
    <content type="html"><![CDATA[<p>Using <a href="http://batmanjs.org">batman.js</a> with <a href="https://github.com/plataformatec/devise">Devise</a> is pretty straightforward.</p>

<!-- more -->


<p>It&rsquo;s also pretty cool-looking, because when you define <code>App.User.current</code>, all your view bindings are instantly updated to reflect the user&rsquo;s signed-in status!</p>

<p>You just have to consider three things:</p>

<ul>
<li>Make Devise communicate in JSON</li>
<li>Make batman.js send Devise-friendly requests</li>
<li>Keep your CSRF token up-to-date</li>
</ul>


<h2>Make Devise Communicate in JSON</h2>

<p>To make your Devise controllers accept and send JSON, register <code>:json</code> as a valid format. Do this by adding to <code>app/config/application.rb</code>:</p>

<p>```ruby</p>

<pre><code>config.to_prepare do
  DeviseController.respond_to :html, :json
end
</code></pre>

<p>```</p>

<p>(From a <a href="https://github.com/plataformatec/devise/issues/2209#issuecomment-12150223">comment on plataformatec/devise</a>)</p>

<p>Now, all the provided Devise controllers will accept the JSON format.</p>

<h2>Make Batman.js Send Devise-friendly Requests</h2>

<p>At time of writing (v0.16), the batman.js rails extra <em>only</em> sends the CSRF token with <code>Batman.RailsStorage</code> storage operations. So, all your requests will be &ldquo;disguised&rdquo; as storage operations.</p>

<p>(These samples include code for updating the CSRF token which is described in detail below)</p>

<h3>Signing In / Signing Up</h3>

<p>I made one form with two states: &ldquo;signing in&rdquo; or &ldquo;signing up&rdquo;. I initialized a User to bind to the form:</p>

<p>```coffeescript
class Funzies.SessionsController extends Funzies.ApplicationController
  new: &ndash;></p>

<pre><code>@set 'user', new Funzies.User
@dialog()
</code></pre>

<p>```</p>

<p>In the form, <code>actionName</code> was either &ldquo;Sign In&rdquo; or &ldquo;Create an Account&rdquo;:</p>

<p>```jade
.row
  .col-xs-12</p>

<pre><code>form data-event-submit='signIn'
  div.alert.alert-danger data-showif='user.errors.length'
    ul
      li data-foreach-e='user.errors' data-bind='e.fullMessage'
  .form-group
    label Email
    input.form-control type='text' data-bind='user.email'
  .form-group
    label Password
    input.form-control type='password' data-bind='user.password'
  .form-group data-showif='signingUp'
    label Password Confirmation
    input.form-control type='password' data-bind='user.password_confirmation'
  .form-group
    .row
      .col-sm-4
        input.btn.btn-primary type='submit' data-bind-value='actionName | append "!"'
      .col-sm-8
        a.pull-right data-event-click='signingUp | toggle' data-bind='otherActionName'
</code></pre>

<p>```</p>

<p><em>(the <code>toggle</code> filter will be released in Batman.js 0.17)</em></p>

<p>It turned out looking like this:</p>

<p><img src="/images/sign_in_form.png" width="500"> <img src="/images/sign_up_form.png" width="500"></p>

<p>Here&rsquo;s the handler for submitting that form. Notice that it handles <em>creating an account</em> and <em>signing up</em>. This might have been stupid of me.</p>

<p>Notice the bit about initializing a new User &mdash; it&rsquo;s because the <code>401</code> puts the user in &ldquo;error&rdquo; state (even with <code>@catchError</code>), which can&rsquo;t be cleared. This stinks and should be fixed in batman.js.</p>

<p>```coffeescript
  signIn: &ndash;></p>

<pre><code>url = if @get('signingUp')
    "/users.json"
  else
    "/users/sign_in.json"
@get('user').save {url}, (err, record, env) =&gt;
  if newToken = env?.data?.csrf_token
    @updateCSRFToken(newToken)
  if err?
    if err instanceof Batman.StorageAdapter.UnauthorizedError
      @set 'user', new Funzies.User(record.toJSON())
      @get('user.errors').add("base", "Email/password don't match our records!")
    else
      console.log(err)
    return
  else
    record.unset('password')
    record.unset('password_confirmation')
    Funzies.User.set('current', record)
    @closeDialog()
</code></pre>

<p>```</p>

<h3>Signing Out</h3>

<p>To send a <code>DELETE</code> request, we&rsquo;ll make a new user, then &ldquo;destroy&rdquo; it:</p>

<p>```coffeescript
  signOut: &ndash;></p>

<pre><code>user = new Funzies.User
user.url = "/users/sign_out.json"
user.destroy (err, record, env) =&gt;
  if newToken = env?.data?.csrf_token
    @updateCSRFToken(newToken)
  Funzies.User.unset('current')
</code></pre>

<p>```</p>

<p>Normally, destroying a not-yet-saved record throws an error. It doesn&rsquo;t throw an error in this case because the storage adapter doesn&rsquo;t check for presence of an ID. (Since we provide a URL, it doesn&rsquo;t need the ID for anything.)</p>

<h2>Keeping the CSRF Token Up-To-Date</h2>

<p>When Rails changes the session, it also provides a new CSRF token for that session. This means that when your user signs in our out, Rails will expect a new CSRF token in the requests from that user. So, make devise send <code>csrf_token</code> when a user signs in or out.</p>

<p>Add to your Devise routes:</p>

<p>```ruby
  devise_for :users, controllers: {</p>

<pre><code>sessions: "users/sessions", # for sending CSRF tokens
</code></pre>

<p>  }
```</p>

<p>Then define the <code>users/sessions</code> controller. Put this in <code>app/controllers/users/sessions_controller.rb</code>:</p>

<p>```ruby
class Users::SessionsController &lt; Devise::SessionsController
  respond_to :json</p>

<p>  def create</p>

<pre><code>resource = warden.authenticate!(
  :scope =&gt; resource_name,
  :recall =&gt; "#{controller_path}#failure"
  )
sign_in_and_redirect(resource_name, resource)
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>sign_out(resource_name)
# on sign-out, send back the CSRF token
render json: {csrf_token: form_authenticity_token}
</code></pre>

<p>  end</p>

<p>  private
  def sign_in_and_redirect(resource_or_scope, resource=nil)</p>

<pre><code>scope = Devise::Mapping.find_scope!(resource_or_scope)
resource ||= resource_or_scope
if warden.user(scope) != resource
  sign_in(scope, resource)
end
# on sign-in, put the CSRF token in the JSON!
return render json: current_user.as_json.merge({csrf_token: form_authenticity_token})
</code></pre>

<p>  end</p>

<p>  def failure</p>

<pre><code>return render :json =&gt; {:success =&gt; false, :errors =&gt; ["Login failed."]}
</code></pre>

<p>  end
end
```</p>

<p>Then, add a way for batman.js to update its <code>Batman.config.CSRF_TOKEN</code>. I put a function on my <code>SessionsController</code>:</p>

<p>```coffeescript
class Funzies.SessionsController
  updateCSRFToken: (token) &ndash;></p>

<pre><code>Batman.config.CSRF_TOKEN = token
</code></pre>

<p>```</p>

<p>That&rsquo;s what I use in <code>signIn</code> and <code>signOut</code> above.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Model Transactions in Batman.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/07/19/model-transactions-in-batman-dot-js/"/>
    <updated>2014-07-19T09:15:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/07/19/model-transactions-in-batman-dot-js</id>
    <content type="html"><![CDATA[<p><code>Model::transaction</code> provides a deep-copied, &ldquo;shadow-realm&rdquo; version of a record which is great for rendering into edit forms. Any changes made to it can be saved (which updates the original record too), or just forgotten.</p>

<!-- more -->


<p>Here&rsquo;s the problem transactions exist to solve:</p>

<ul>
<li>You want your user to edit something</li>
<li>You render a record into an edit form</li>
<li>User edits the form</li>
<li>User clicks back button</li>
<li>User is surprised to see that the record&rsquo;s changes were &ldquo;saved&rdquo; (In fact, only the in-memory record was changed &mdash; the change wasn&rsquo;t sent to the server)</li>
</ul>


<p><code>Model::transaction</code> solves this problem by returning a <em>deep copy</em> of the record at hand which can be:</p>

<ul>
<li><strong>saved</strong>, just like a normal record, in which case changes are applied to the original</li>
<li><strong>forgotten</strong>, by simply navigating away</li>
<li><strong>applied</strong>, which applies changes to the original, but doesn&rsquo;t update the server.</li>
</ul>


<p><em>The name &ldquo;transaction&rdquo; hearkens back to database transactions where changes aren&rsquo;t applied unless they&rsquo;re all successful. In the same way, changes to a <code>Batman.Transaction</code> aren&rsquo;t applied unless you explicitly <code>save</code> or <code>applyChanges</code>.</em></p>

<h2>Setting up a Transaction</h2>

<p>To set up a transaction, call <code>transaction</code> on the record at hand:</p>

<p>```coffeescript
class MyApp.RaceHorsesController extends MyApp.ApplicationController
  edit: (params) &ndash;></p>

<pre><code>MyApp.RaceHorse.find params.id, (err, record) -&gt;
  deepCopy = record.transaction()
  @set 'raceHorse', deepCopy
</code></pre>

<p>```</p>

<h2>Transaction&rsquo;s Deep Copy</h2>

<p>A transaction is actually an instance of the original model. It differs in 2 ways:</p>

<ul>
<li>It isn&rsquo;t added to the <code>loaded</code> set (aka &ldquo;the memory map&rdquo;)</li>
<li>It has <code>Batman.Transaction</code> mixed in, which defines some new functions and overrides <code>Model::save</code></li>
</ul>


<p><code>Model::transaction</code> peforms a deep copy of a <code>Batman.Model</code> by
 iterating over the model&rsquo;s <code>attributes</code> hash. The <code>attributes</code> hash is where encoded properties are stored (and other properties, unless you define an accessor that says otherwise).</p>

<p>Batman.js copies the attributes hash into the transaction by handling each value:</p>

<ul>
<li>If the value is a <code>Batman.Model</code>, it&rsquo;s also copied with <code>Model::transaction</code></li>
<li>If the value is a <code>Batman.AssociationSet</code>, it&rsquo;s cloned into a <code>Batman.TransactionAssociationSet</code> and its members are copied with <code>Model::transaction</code></li>
<li>Otherwise, the value is set into the transaction&rsquo;s attributes.</li>
</ul>


<p>Under the hood, batman.js tracks which objects it has already cloned. That way, it doesn&rsquo;t get thrown into an infinite loop.</p>

<p>If a mutable object is copied from the original to the transaction, batman.js issues a warning. This is because it can&rsquo;t isolate changes. The transaction and the original are both refering to the <em>same object</em>, so changes to one will also affect the other. Mutable objects include:</p>

<ul>
<li>Dates (although mutating dates is such a pain in JS, I doubt this will cause a problem)</li>
<li>Arrays</li>
<li>Batman.Set, Batman.Hash, etc</li>
<li>any JavaScript object</li>
</ul>


<h2>Saving a Transaction</h2>

<p>To save a transaction, call <code>save</code> on it. This will:</p>

<ul>
<li>validate the transaction (with client-side validations)</li>
<li>apply changes to the original model</li>
<li>save the transaction (ie, the storage operation will be performed with the transaction, not the original)</li>
<li>pass the original to the <code>save</code> callback</li>
</ul>


<p>This means a transaction behaves just like a normal model. You can save it like this:</p>

<p>```coffeescript
  saveRaceHorse: (raceHorse) &ndash;></p>

<pre><code>raceHorse.isTransaction # =&gt; true, just checking
raceHorse.save (err, record) -&gt;
  if !err
    Batman.redirect("/race_horses")
</code></pre>

<p>```</p>

<p><strong>Note:</strong> at time of writing, transaction <strong>does not account for server-side validations</strong>. There is an open issue for this <a href="https://github.com/batmanjs/batman/issues/1049">on github</a>.</p>

<h2>Forgetting a Transaction</h2>

<p>If you don&rsquo;t want changes on transaction to be applied, just leave it alone.</p>

<ul>
<li>It&rsquo;s not in the <code>loaded</code> set, so it won&rsquo;t intefere with your app&rsquo;s other data.</li>
<li>The original record has no references to it.</li>
<li>It&rsquo;s still set on your controller (probably), but it will get overrided next time your user edits something.</li>
</ul>


<p>Once it&rsquo;s released from the controller, it will probably just be garbage-collected when the browser gets a chance.</p>

<h2>Applying Changes without Saving</h2>

<p>Transactions have an <code>applyChanges</code> function that updates the original record without performing any storage operations.</p>

<p><code>coffeescript
transaction.applyChanges()
</code></p>

<p>You might use this if your save operation is really complicated and you need to control it by hand.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Batman.js Accessors as Methods]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/06/27/batman-dot-js-accessors-as-methods/"/>
    <updated>2014-06-27T08:10:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/06/27/batman-dot-js-accessors-as-methods</id>
    <content type="html"><![CDATA[<p><a href="http://batmanjs.org">Batman.js</a> is a CoffeeScript front-end MVC framework. One of its core features is <em>accessors</em>, which can be used like properties or methods of a <code>Batman.Object</code>. They can even take arguments!</p>

<!-- more -->


<p><code>Batman.Object</code> has properties defined with <code>@accessor</code> in the class definition. Examples of <code>@accessor</code> as accessible properties and computed properties are bountiful. However, I recently learned that accessors can also be made to take arguments, too!</p>

<p><em>(You can see this example live on at <a href="http://jsbin.com/dalodifo/3/edit">http://jsbin.com/dalodifo/3/edit</a> .)</em></p>

<h2>Definining Accessors with Arguments</h2>

<p>To make an accessor that takes arguments, use <code>Batman.TerminalAccessible</code>. Let&rsquo;s say I have a <code>MathObject</code> which stores a <code>value</code> and allows you to perform calculations on it:</p>

<p>```coffeescript
class MathObject extends Batman.Object
  @accessor &lsquo;value&rsquo;</p>

<p>  @accessor &lsquo;times&rsquo;, &ndash;></p>

<pre><code>new Batman.TerminalAccessible (multiplier) =&gt;
  @get('value') * multiplier
</code></pre>

<p>```</p>

<p>Now, my <code>times</code> accessor takes an argument (<code>multiplier</code>) and returns the multiplied value. I pass the argument with <code>get</code>, like this:</p>

<p><code>coffeescript
fiveObject = new MathObject(value: 5)
fiveObject.get('time').get(10) # =&gt; 50
fiveObject.get('time').get(3)  # =&gt; 15
</code></p>

<p>Under the hood, <code>fiveObject.get('time')</code> returns a <code>Batman.TerminalAccessible</code>. This object provides <a href="/blog/2014/04/20/automatic-source-tracking-in-batman-dot-js/">source tracking</a> for the function that it calls.</p>

<h2>Objects as Arguments</h2>

<p>You can also have <code>Batman.Objects</code> as arguments. For example, if we wanted to multiply two <code>MathObject</code>s:</p>

<p>```coffeescript
class MathObject extends Batman.Object
  @accessor &lsquo;value&rsquo;</p>

<p>  @accessor &lsquo;timesMathObject&rsquo;, &ndash;></p>

<pre><code>new Batman.TerminalAccessible (mathObj) =&gt;
  @get('times').get(mathObj.get('value'))
</code></pre>

<p>```</p>

<p>Now, the other <code>mathObj</code> will be included in the source tracking. If <code>mathObj.value</code> changes, the value will be recalculated.  This is <strong>essential</strong> for values computed from two <code>Batman.Object</code>s!</p>

<h2>What&rsquo;s the point?</h2>

<p>This allows <strong>observable</strong> &ldquo;method calls&rdquo;. It&rsquo;s wrapped in batman.js <a href="/blog/2014/04/20/automatic-source-tracking-in-batman-dot-js/">source tracking</a>, so whenever the object or the arguments change, the value will be recalculated.</p>

<p>For example, I use it for checking whether a room is at maximum occupancy for certain events:</p>

<p><code>coffeescript
location.get('isFullFor').get(earlyEvent) # =&gt; false
location.get('isFullFor').get(lateEvent)  # =&gt; true
</code></p>

<p>When people attend the event (or the location max occupancy is changed), these values are automatically recalculated!</p>

<p>This is the same approach used in batman.js internals for accessing SetIndexes (<a href="https://github.com/batmanjs/batman/blob/master/src/set/set.coffee#L19">source</a>).</p>

<h2>Accessor Arguments in View Bindings</h2>

<p>To pass arguments to accessors in view bindings, you can use the <code>[...]</code> or <code>withArguments</code> filters. Let&rsquo;s say I want to put this operation in a view binding:</p>

<p><code>coffeescript
location.get('isFullFor').get(earlyEvent)
</code></p>

<p><code>[...]</code> is shorthand for calling <code>get</code> with the given argument. I can use it like this:</p>

<p><code>html
&lt;span data-bind='location.isFullFor[earlyEvent]'&gt;&lt;/span&gt;
</code></p>

<p><code>earlyEvent</code> will be looked up in context and the value will be passed to <code>get</code>, as in the CoffeeScript above.</p>

<p>You can also use the <code>withArguments</code> filter (as of 0.16, <a href="https://github.com/batmanjs/batman/pull/923">PR</a>) like this:</p>

<p><code>html
&lt;span data-bind='location.isFullFor | withArguments earlyEvent'&gt;&lt;/span&gt;
</code></p>

<p><code>withArguments</code> recognizes that it should use <code>get</code> in this case.</p>
]]></content>
  </entry>
  
</feed>
