<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Batman.js | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/batman-dot-js/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2014-09-07T20:48:13-07:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why (I Think) We're Leaving Batman.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/09/07/why-i-think-were-leaving-batman-dot-js/"/>
    <updated>2014-09-07T20:19:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/09/07/why-i-think-were-leaving-batman-dot-js</id>
    <content type="html"><![CDATA[<p>Sadly, <a href="http://get.planningcenteronline.com">PCO</a> is getting out of the batman.js game.</p>

<!-- more -->


<p>From where I sit, I think it boils down to:</p>

<ul>
<li>The framework never hit critical mass (and lost what it had)</li>
<li>The framework&rsquo;s magic made some problems impossible to debug</li>
<li>Client-side apps aren&rsquo;t good for business</li>
<li>Rails, Turbolinks &amp; React will do just fine</li>
</ul>


<p>After discussing those issues, I&rsquo;ll say where I think I&rsquo;m going next. Batman.js is a great framework with some amazing, well-tested features and I&rsquo;m sorry to see it go this way for us!</p>

<h2>No Critical Mass</h2>

<p>Batman.js was an early entrant to the &ldquo;Framework Wars&rdquo;. It was production-ready by early 2013, which made it appealing at that point. However,</p>

<ul>
<li>there was very little &ldquo;evangelism&rdquo; by its creators (almost no talks, very little documentation, no &ldquo;media presence&rdquo;)</li>
<li>early adopters were not &ldquo;invited in&rdquo; (unanswered github issues, for example)</li>
</ul>


<p>When Shopify pulled out (around <a href="https://github.com/batmanjs/batman/graphs/contributors">fall 2013</a>?), a ton of knowledge and resources were removed with no viable replacement.</p>

<h2>Magic Problems</h2>

<p>Batman.js is loaded with awesome APIs that were fun to use and satisfying when they worked. However, when it <em>didn&rsquo;t work</em>, you were up a creek without a paddle. There was:</p>

<ul>
<li>no helpful error messages</li>
<li>no support on github, stack overflow or IRC</li>
<li>no documentation or information of any kind about the inner workings</li>
<li>no debugging tools</li>
</ul>


<p>I&rsquo;ve seen a lot of batman.js users pull their hair out yelling, &ldquo;Why doesn&rsquo;t this <em>work</em>?!&rdquo; Indeed, that&rsquo;s what drove me to learn it from the source.</p>

<h2>Client-Side Issues</h2>

<p>Making a whole app in JavaScript has a lot of sex appeal, but several things make it bad for real-life business:</p>

<ul>
<li>Bug-tracking tools (namely Bugsnag for JS) are not as good (especially when you throw CoffeeScript &amp; minification in the mix)</li>
<li>Browser environments are outside your control (I got a lot of bugsnags for peoples' browser extensions)</li>
<li>State can get weird &mdash; after having the app open for an hour, data can just get messed up! (Maybe this doesn&rsquo;t happen for better programmers.)</li>
</ul>


<p>You just don&rsquo;t realize the luxury of reliable bugsnags until they&rsquo;re gone! So many Check-Ins bugsnags leave no trace of what actually went wrong.</p>

<h2>Other Options are OK, too</h2>

<p>We have a solid data model, HTML templates and CSS to boot. It stinks to throw away all that code, but I forgot how amazingly fast it is to code Ruby on Rails.</p>

<p>JS MVC types will look down their noses at Turbolinks, but it <em>works</em> and it has a lot of eyes on it. Combined with <code>react-rails</code>, it&rsquo;s a really strong option!</p>

<h2>What Now?</h2>

<p>In short, Rails-rendered HTML, Turbolinks &amp; <code>form_for ... remote: true</code>, and ReactJS for live-updates. There are a few things I am looking forward to:</p>

<ul>
<li><strong>RUBY BUGSNAGS</strong> with stack traces, request environments and everything!</li>
<li><strong>Less state.</strong> Fewer things that can randomly affect other things in ways I didn&rsquo;t think about.</li>
<li><strong>ReactJS.</strong> <code>Batman.View</code> is an amazing thing, but it makes me appreciate the dead-simple API of a React component. It can only get data from one place, no other objects can mess with it, its lifecycle is <em>very</em> simple (and works as documented), etc etc. I write a lot more code to do a lot less with React, but I think it&rsquo;s going to be a lot more stable, and that&rsquo;s worth it.</li>
</ul>


<p>We held on to Batman.js for a long time because it lended itself to <em>live-updating everything</em>. I think React is going to cover the a few key things there, and just <em>changing pages</em> will do the rest. So far I&rsquo;ve hooked up Pusher to Flux-style stores, then wrapped anything live-updating in a React component that observes that store. It&rsquo;s a lot more hands-on than Batman.js updates, but it has other advantages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Render Scope in AngularJS and Batman.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/08/10/render-scope-in-angular-dot-js-and-batman-dot-js/"/>
    <updated>2014-08-10T18:45:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/08/10/render-scope-in-angular-dot-js-and-batman-dot-js</id>
    <content type="html"><![CDATA[<p><a href="http://batmanjs.org">Batman.js</a> and <a href="http://angularjs.org">AngularJS</a> both create hierarchical view scopes, but their implementations are very different.</p>

<!-- more -->


<p><em>(please forgive my inconsistent rendering of AngularJS/Angular/Angular.js/angular, I don&rsquo;t know which one is right!)</em></p>

<p>In batman.js and Angular, there is a view scope <em>hierarchy</em> which mirrors the DOM. In this heirarchy, objects may:</p>

<ul>
<li>add values into the render scope</li>
<li>access <em>their own</em> values</li>
<li>belong to a <em>parent object</em></li>
<li>access values from <em>their parents</em></li>
<li>have <em>child objects</em> of their own</li>
</ul>


<p>Consider a page like this:</p>

<p><a href="/images/batmanjs_nested_views.png"><img src="/images/batmanjs_nested_views.png" alt="Batman.js view hierarchy" /></a></p>

<p>The <code>HouseholdView</code> has many child views. The <code>PersonView</code>s belong to their parent, <code>HouseholdView</code>. They may access values from <code>HouseholdView</code> (such as the shared <code>householdName</code>).</p>

<p><em>Note: The batman.js view hierarchy includes a few other objects as well &mdash; see below.</em></p>

<h1>Finding Values in the Hierarchy</h1>

<p>To answer the question &ldquo;how can child views access data from their parents&rdquo;, Batman.js and Angular take different approaches.</p>

<h3>$scope &amp; Prototypal Inheritance</h3>

<p>In Angular, data bindings are evaluated against a <strong>magical <code>$scope</code> object</strong>. The scope object has key-value pairs which correspond to values in the data bindings. When <code>$scope</code>s are created, Angular massages (tampers with?) the prototypal inheritance chain so that a child scope&rsquo;s prototype <em>is</em> its parent scope.</p>

<p>(Usually, an object&rsquo;s prototype is another &ldquo;pristine&rdquo; object of its same type. It&rsquo;s generally treated as the &ldquo;perfect instance&rdquo; of the type. Other instances delegate to the prototype for properties that aren&rsquo;t defined explicitly on themselves.)</p>

<p>In this case, a child <code>$scope</code>&rsquo;s prototype is not a &ldquo;pristine instance&rdquo;, but instead it&rsquo;s the parent <code>$scope</code> object. That way, if a value isn&rsquo;t found in a child scope, it is looked up in the prototype chain. This is <strong>brilliant</strong>. Angular delegates value lookup to built-in JavaScript features. (There is one gotcha described below.)</p>

<p>When a parent <code>$scope</code> has many children, all children have the same parent <code>$scope</code> object as their prototype.</p>

<h3>Batman.View &amp; View::lookupKeypath</h3>

<p>Batman.js builds a <strong>tree of <code>Batman.View</code> objects</strong>. The root of the tree is called the <code>LayoutView</code> and it is created automatically by batman.js. Each view keeps track of its children in its <code>subviews</code>, which is a <code>Batman.Set</code> containing views that are rendered inside it. Each view also keeps track of its <code>superview</code>, which is its parent <code>Batman.View</code>.</p>

<p>To evaluate data bindings, batman.js uses <code>lookupKeypath</code> on the view in question. This function climbs the &ldquo;view hierarchy&rdquo;, which actually includes a few extra objects:</p>

<ul>
<li>The <code>Batman.Controller</code> instance which rendered the view</li>
<li><code>Batman.currentApp</code>, which is the <code>Batman.App</code> subclass that you defined (the clas, not an instance)</li>
<li><code>Batman.container</code>, which is usually <code>window</code></li>
</ul>


<p>Here&rsquo;s the whole view hierarchy from the previous example:</p>

<p><a href="/images/batmanjs_nested_views_whole_tree.png"><img src="/images/batmanjs_nested_views_whole_tree.png" alt="The whole batman.js view hierarchy" /></a></p>

<p>Since <code>Batman.currentApp</code> is in the view hierarchy, any <code>@classAccessor</code>s you define there are accessible in view bindings, akin to global scope in JavaScript.</p>

<h1>Automatically-Created Scopes</h1>

<p>In batman.js and Angular, there are data bindings that create child scopes of their own. For example, <code>ng-repeat</code> and <code>data-foreach</code> both create a collection of child scopes with the same parent.</p>

<p>Angular does this by creating many child <code>$scopes</code> with the same parent <code>$scope</code> as their prototype.</p>

<p>Batman.js does this by automatically adding nodes to the view hierarchy. One downside of batman.js is that creating lots and lots of new views is CPU-intensive. I don&rsquo;t know whether the same is true for creating <code>$scope</code>s.</p>

<h1>How Does It Know Which Scope to Bind To?</h1>

<p>When I was reading about <code>$scope</code>, I learned that some new Angular users hit a snag when they try to set values on a <em>parent scope</em> from within a <em>child scope</em>. As JavaScript should, it updates the child <code>$scope</code> with the new value, not the parent <code>$scope</code>, which is the child&rsquo;s prototype.</p>

<p>That&rsquo;s how prototypal inheritance works: It looks up missing values on the prototype, but it sets <em>new</em> values on the instance. Then, it stops &ldquo;falling back&rdquo; to the prototype for the property that was set on the instance.</p>

<p>To work around this, it&rsquo;s recommended to &ldquo;always use a <code>.</code> in your <code>ng-model</code>s&rdquo;. (<code>ng-model</code> is a binding that creates a child scope.)</p>

<p>Batman.js doesn&rsquo;t have this problem because, when uses <code>lookupKeypath</code>, it remembers which <code>View</code> object was the target for that keypath, then updates <em>that object</em> whenever the keypath changes.</p>

<p>However, Batman.js is prone to a different gotcha. If you leave an accessor unset (ie, returns <code>undefined</code>), then set it <em>after</em> a view has rendered, it&rsquo;s possible that <code>View::lookupKeypath</code> won&rsquo;t find it correctly. To avoid this, set defaults (or <code>null</code>) before bindings are evaluated:</p>

<ul>
<li>before <code>@render</code> in controller actions</li>
<li>in the <code>constructor</code> for view instances</li>
</ul>


<p>Or, make sure <code>@accessor</code>s return <code>null</code> instead of <code>undefined</code>.</p>

<p>Batman.js treats <code>undefined</code> as the signal that an object doesn&rsquo;t have an accessor for a keypath, so be careful when setting keys <code>undefined</code>!</p>

<h1>How Does It Know When to Update the DOM?</h1>

<p>When these scope objects (<code>View</code> or <code>$scope</code>) change, the framework must update the DOM accordingly.</p>

<p>Angular has a &ldquo;digest cycle&rdquo; where it checks for changes in the <code>$scope</code> since last run, then updates the DOM if necessary. It automatically tracks any values that are put into templates. You can also watch other keys on <code>$scope</code> with <code>$scope.$watch</code>. If you modify <code>$scope</code> from <em>outside</em> Angular.js code, you must manually trigger the digest cycle with <code>$scope.$apply</code>.</p>

<p><code>Batman.View</code> uses the <a href="http://rmosolgo.github.io/blog/2014/04/20/automatic-source-tracking-in-batman-dot-js/"><code>Batman.Property</code></a> system to automatically track dependencies and changes. Any keypath that is passed to a <code>data-</code> binding is automatically observed. DOM updates are triggered when:</p>

<ul>
<li>A keypath is updated with <code>set</code>. Doesn&rsquo;t matter whether it&rsquo;s inside batman.js code or inside an AJAX callback &mdash; batman.js will recognize the update either way.</li>
<li>A property&rsquo;s dependencies change. When you declare a computed property with <code>@accessor</code> and bind it to a view, the view will update the DOM whenever that property&rsquo;s dependencies cause it to change.</li>
</ul>


<p>(In fact, those two cases are the heart of observability in batman.js: assign a value with <code>set</code> or delegate to batman.js&rsquo;s source tracking.)</p>

<p>To force an update, use <code>set</code> to update a bound property or one of its dependencies.</p>

<h1>Other Random Points</h1>

<ul>
<li>Angular&rsquo;s &ldquo;evalute an expression&rdquo; is like batman.js&rsquo;s &ldquo;lookup a keypath&rdquo;</li>
<li><code>Batman.View::propagateToSubviews</code> is like <code>$scope.$broadcast</code>: it sends messages down the view tree.</li>
<li>As of batman.js almost-v0.17, there is no analog for <code>$scope.$emit</code> (which sends events <em>up</em> the view chain)</li>
<li>batman.js exports global function <code>$context($0)</code> which is just like <code>angular.element($0).scope()</code> (where <code>$0</code> is the highlighted element in the Chrome inspector).</li>
</ul>


<h1>My Opinion</h1>

<p>I think Angular&rsquo;s <code>$scope</code> is brilliant. I imagine it&rsquo;s performant as well, although I don&rsquo;t know (and I&rsquo;m currently writing without internet access). It introduces few gotchas. In general, it seems like it Just Works<sup>TM</sup>.</p>

<p>I&rsquo;m in the market to improve the performance of <code>Batman.View</code>, but I&rsquo;m not sure I can take anything from <code>$scope</code>. All of batman.js depends on playing by the observability rules. I don&rsquo;t see any way I can get native JS prototypal inheritance to participate in that.</p>

<p>I also like sticking with the &ldquo;It&rsquo;s just batman.js&rdquo; in the view layer. If you can write good <code>@accessor</code>s, then you&rsquo;ve mastered <code>Batman.View</code>, too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Computed Properties: Batman.js and Ember.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/08/02/computed-properties-batman-dot-js-and-ember-dot-js/"/>
    <updated>2014-08-02T09:38:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/08/02/computed-properties-batman-dot-js-and-ember-dot-js</id>
    <content type="html"><![CDATA[<p><a href="http://batmanjs.org">Batman.js</a> is a front-end MVC framework with an unrivaled implementation of key-value observing. I will explore computed properties in batman.js by contrasting them with Ember.js&rsquo;s computed properties.</p>

<!-- more -->


<p>First, disclaimers!</p>

<ul>
<li>I didn&rsquo;t write any of the <code>Batman.Property</code> code that makes this feature possible. I&rsquo;m only a fanboy!</li>
<li>I don&rsquo;t know Ember.js. I&rsquo;ve just gathered examples from the <a href="http://emberjs.com/guides">Ember Guides</a>.</li>
</ul>


<p>To explore computed properties, let&rsquo;s take the <strong>canonical <code>fullName</code> example</strong>. It:</p>

<ul>
<li>depends on two other properties, <code>firstName</code> and <code>lastName</code></li>
<li>returns a string that joins <code>firstName</code> and <code>lastName</code> with a space</li>
<li>can be set</li>
<li>sets <code>firstName</code> and <code>lastName</code> by splitting on whitespace</li>
</ul>


<p>We&rsquo;ll also explore an <strong>aggregrated <code>roster</code> property</strong> which:</p>

<ul>
<li>depends on <code>fullName</code> for each person</li>
<li>joins <code>fullName</code> with <code>,</code></li>
</ul>


<h2>fullName in Ember.js</h2>

<p>(This is yanked wholesale from the <a href="http://emberjs.com/guides/object-model/computed-properties/">Computed Properties Guide</a>.)</p>

<p>A couple of things to notice:</p>

<ul>
<li><code>fullName</code> is defined as <em>one function</em> which handles <code>get</code> and <code>set</code> operations.</li>
<li><code>fullName</code> must be told what properties it depends on.</li>
</ul>


<p>```javascript
App.Person = Ember.Object.extend({
  firstName: null, // These aren&rsquo;t necessary, they&rsquo;re
  lastName: null,  // just for clarity.</p>

<p>  fullName: function(key, value, previousValue) {</p>

<pre><code>// setter
if (arguments.length &gt; 1) {
  var nameParts = value.split(/\s+/);
  this.set('firstName', nameParts[0]);
  this.set('lastName',  nameParts[1]);
}

// getter, also the return value is cached
return this.get('firstName') + ' ' + this.get('lastName');
</code></pre>

<p>  }.property(&lsquo;firstName&rsquo;, &lsquo;lastName&rsquo;)
});
```</p>

<p>Usage is pretty standard: use <code>get</code> and <code>set</code> to access properties.</p>

<p><code>javascript
var captainAmerica = App.Person.create();
captainAmerica.set('fullName', "William Burnside");
captainAmerica.get('firstName'); // William
captainAmerica.get('lastName');  // Burnside
</code></p>

<h2>fullName in Batman.js</h2>

<p>Two things to notice:</p>

<ul>
<li><code>get</code> and <code>set</code> operations are defined <em>separately</em>.</li>
<li><code>fullName</code> doesn&rsquo;t have to be told what its dependencies are.</li>
</ul>


<p>```coffeescript
class App.Person extends Batman.Object
  @accessor &lsquo;firstName&rsquo; # not necessary,
  @accessor &lsquo;lastName&rsquo;  # just here for clarity</p>

<p>  @accessor &lsquo;fullName&rsquo;,</p>

<pre><code>get: (key) -&gt; "#{@get('firstName')} #{@get('lastName')}"
set: (key, value) -&gt;
  nameParts = value.split(/\s+/)
  @set('firstName', nameParts[0])
  @set('lastName', nameParts[1])
  return value # should return newly-set value, although the `get` function will be used for caching.
</code></pre>

<p>```</p>

<p>The usage is almost identical:</p>

<p><code>coffeescript
captainAmerica = new App.Person
captainAmerica.set('fullName', 'William Burnside')
captainAmerica.get('firstName') # William
captainAmerica.get('lastName')  # Burnside
</code></p>

<h2>roster in Ember.js</h2>

<p>(This was adapted from the <a href="http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/">Computed Properties and Aggregate Data Guide</a>.)</p>

<p>Some things stood out to me:</p>

<ul>
<li><code>roster</code>&rsquo;s properties are declared with a DSL. Array dependencies are limited to one layer deep (ie, you can&rsquo;t use <code>@each</code> twice).</li>
<li><code>mapBy</code> is provided by <code>Ember.Enumerable</code> to handle arrays of objects. Nice!</li>
</ul>


<p>```javascript
App.PeopleController = Ember.Controller.extend({
  people: [</p>

<pre><code>App.Person.create({firstName: "Tom", lastName: "Dale"}),
App.Person.create({firstName: "Yehuda", lastName: "Katz"})
</code></pre>

<p>  ],</p>

<p>  roster: function() {</p>

<pre><code>var people = this.get('people');
return people.mapBy('fullName').join(', ');
</code></pre>

<p>  }.property(&lsquo;<a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x70;&#101;&#111;&#x70;&#x6c;&#x65;&#x2e;&#64;&#101;&#97;&#x63;&#x68;&#x2e;&#102;&#117;&#x6c;&#108;&#78;&#97;&#109;&#x65;">&#x70;&#101;&#111;&#112;&#108;&#x65;&#46;&#64;&#x65;&#97;&#x63;&#x68;&#46;&#102;&#x75;&#x6c;&#x6c;&#x4e;&#97;&#109;&#101;</a>&rsquo;)
});
```</p>

<h2>roster in Batman.js</h2>

<p>Here&rsquo;s the analogous construction in batman.js:</p>

<p>```coffeescript
class App.PeopleController extends Batman.Controller
  @accessor &lsquo;people&rsquo;, &ndash;></p>

<pre><code>new Batman.Set([ # this is future-code: constructor will take an array in v0.17.0
  new App.Person(firstName: "Tom", lastName: "Dale")
  new App.Person(firstName: "Yehuda", lastName: "Katz")
])
</code></pre>

<p>  @accessor &lsquo;roster&rsquo;, &ndash;></p>

<pre><code>@get('people').mapToProperty('fullName').join(', ')
</code></pre>

<p>```</p>

<p>One thing is the same:</p>

<ul>
<li><code>mapToProperty</code> works like <code>mapBy</code></li>
</ul>


<p>You might notice two big differences:</p>

<ul>
<li><code>people</code> is a <code>Batman.Set</code> instead of a native Array.</li>
<li><code>roster</code> didn&rsquo;t have to be told what its dependencies are</li>
</ul>


<p>By using batman.js data structures inside <code>@accessor</code> functions, we benefit from batman.js&rsquo;s <a href="http://rmosolgo.github.io/blog/2014/04/20/automatic-source-tracking-in-batman-dot-js/">automatic source tracking</a>. It looks like automatic source tracking was considered by the Ember core team, but deemed <a href="https://github.com/emberjs/ember.js/issues/269#issuecomment-3178319">impossible</a> or <a href="https://github.com/emberjs/ember.js/issues/386#issuecomment-3523589">prohibitively expensive</a>.</p>

<p>I recently saw a quote in a <a href="https://www.youtube.com/watch?v=-DX3vJiqxm4">React.js talk</a>:</p>

<blockquote><p>Intellectuals solve probelms. Geniuses prevent them. &ndash; Albert Einstein</p></blockquote>

<p>I think that&rsquo;s just what the Shopify team did when they implemented <code>Batman.Observable</code>! The API is very simple and it Just Works<sup>TM</sup>.</p>

<h2>My Opinion</h2>

<p><strong>Pros of batman.js:</strong></p>

<ul>
<li>Elegant <code>@accessor</code> API for getters and setters: define <code>get</code> and <code>set</code> separately instead of testing for arguments.</li>
<li>Automatic dependency tracking: batman.js knows what objects &amp; properties were accessed during computation and observes accordingly.</li>
<li>There&rsquo;s no limit to the depth of enumerable dependencies. Any property of a <code>Batman.Object</code> that&rsquo;s accessed will be tracked, no matter where it exists in the app.</li>
</ul>


<p>In fact, <code>@accessor</code> is the heart and soul of a batman.js app. You&rsquo;re basically declaring a system of computed properties, then updating that system from user input. Batman.js propagates information to wherever it needs to be.</p>

<p><strong>Cons of batman.js:</strong></p>

<ul>
<li>&ldquo;It&rsquo;s just not Ember.&rdquo; You miss out on huge user base, corporate support, and everything that goes with that.</li>
<li>Beyond that, batman.js resources are sparse. The <a href="http://batmanjs.org/docs/index.html">new guides</a>, <a href="https://www.softcover.io/read/b5c051f3/batmanjs_mvc_cookbook">cookbook</a> and <a href="http://batmanjs.org/docs/index.html">API docs</a> are improving every week, but for advanced usage you still have to sourcedive sometimes.</li>
<li>There <strong>is</strong> a performance hit for global observability. The only place I&rsquo;ve noticed it is with complex iteration views (<a href="https://github.com/batmanjs/batman/issues/1086">batmanjs/batman#1086</a>). I&rsquo;m hoping to tackle this soon since it&rsquo;s becoming an issue in <a href="http://get.planningcenteronline.com/check-ins">PCO Check-ins</a>.</li>
</ul>


<p>I&rsquo;m not aware of any features missing from batman.js, but I do miss the &ldquo;googleability&rdquo; of a well-traveled path. Batman.js also lacks some of the dev tools like a decent Chrome extension and a command-line client.</p>

<p>I always want to know <em>how</em> things works, so getting in the source is actually a benefit for me.</p>

<p><strong>Six of one, half-dozen of the other:</strong></p>

<ul>
<li>Dependency DSL vs <code>Batman.{DataStructure}</code></li>
<li>Calling super: <code>this._super</code> vs. <code>@wrapAccessor</code></li>
<li>External API with <code>get</code> and <code>set</code></li>
<li>Cached values in computed properties</li>
<li>In batman.js, you can opt out of tracking with <code>Batman.Property.withoutTracking</code>. It&rsquo;s obscure, but I think it&rsquo;s ok because batman.js always covers the more common case.</li>
</ul>


<p>One thing that I found in neither framework was rate-limited properties, a la Knockout. I&rsquo;d love to have a built-in option for this in batman.js.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Handlers in Batman.js]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/07/28/event-handlers-in-batman-dot-js/"/>
    <updated>2014-07-28T13:23:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/07/28/event-handlers-in-batman-dot-js</id>
    <content type="html"><![CDATA[<p>In <a href="http://batmanjs.org">batman.js</a>, event handlers respond to user interactions like &ldquo;click&rdquo; and &ldquo;submit&rdquo;. You can use them to modify application state in response to those interactions.</p>

<!-- more -->


<p>Let&rsquo;s look at:</p>

<ul>
<li>What event handlers are and where they&rsquo;re defined</li>
<li>How you can connect handlers to DOM events</li>
<li>How you can pass arguments to event handlers</li>
<li>What <code>@</code> refers to inside event handlers</li>
</ul>


<h2>What Are Event Handlers?</h2>

<p>In short, an <em>event handler</em> can be <em>any function inside the render context</em>.</p>

<p>Usually, this means it&rsquo;s a prototype function on a view:</p>

<p><code>coffeescript
class MyApp.ItemsIndexView extends Batman.View
  myEventHandler: -&gt; # handle some event
</code></p>

<p>or, it&rsquo;s a prototype function on a controller:</p>

<p><code>coffeescript
class MyApp.ItemsController extends MyApp.ApplicationController
  myEventHandler: -&gt; # handle some event
</code></p>

<p>Since the main <code>MyApp</code> is also inside the render context, you can also use class functions on the app as event handlers:</p>

<p><code>coffeescript
class window.MyApp extends Batman.App
  @myEventHandler: -&gt; # handle some event
</code></p>

<p><strong>All</strong> of those functions are fair game to be wired up as event handlers.</p>

<h2>Hooking up Event Handlers</h2>

<p>To connect a function to a DOM event, use the <code>data-event</code> binding. You can bind to pretty much any event (I don&rsquo;t know of one that you <em>can&rsquo;t</em> bind to).</p>

<p>The binding takes the form:</p>

<p><code>coffeescript
"data-bind-#{eventName}='#{handlerName}'"
</code></p>

<p>For example, to bind a <code>click</code> event to <code>myEventHandler</code> on this <code>&lt;button&gt;</code>:</p>

<p><code>html
&lt;button data-event-click='myEventHandler'&gt;Click Me&lt;/button&gt;
</code></p>

<p>You can also bind to the <code>submit</code> event of a <code>&lt;form&gt;</code>:</p>

<p><code>html
&lt;form data-event-submit='saveData'&gt;
  &lt;input type='submit'&gt;Save&lt;/input&gt;
&lt;/form&gt;
</code></p>

<h2>Arguments in Event Handlers</h2>

<p>Event handlers have two sets of arguments:</p>

<ul>
<li>arguments that you pass in via <code>withArguments</code> filters</li>
<li>arguments that are automatically passed in by batman.js</li>
</ul>


<h3>Custom Arguments with &ldquo;withArguments&rdquo;</h3>

<p>You can choose some values to pass in with a <code>withArguments</code> filter in your binding.</p>

<p>Consider this event handler:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName)
</code></pre>

<p>```</p>

<p>I could call this with an <code>item</code> by using a <code>withArguments</code> filter:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item'>Alert!</button>
```</p>

<p>You can pass multiple arguments with <code>withArgument</code> by separating them with commas.</p>

<p>For example, if I want more flexible alerts, I could redefine the event handler to take <em>two</em> arguments:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item, punctuation) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName + punctuation)
</code></pre>

<p>```</p>

<p>Then, pass <em>two</em> arguments into it, separated with <code>,</code>:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item, "!" '>Alert!</button>
<button data-event-click='alertItemName | withArguments item, "?" '>Alert?</button>
<button data-event-click='alertItemName | withArguments item, "." '>Alert.</button>
```</p>

<p><strong>Note</strong> that you <strong>must</strong> provide both arguments to the handler. If you don&rsquo;t, batman.js&rsquo;s automatic arguments will take the place of the missing argument!</p>

<h3>Automatic Arguments</h3>

<p>When batman.js invokes an event handler, it <strong>automatically passes in</strong> a few arguments. Here&rsquo;s a handler that uses the automatic arguments:</p>

<p><code>coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  myEventHandler: (node, event, view) -&gt;
</code></p>

<p>It&rsquo;s invoked with:</p>

<ul>
<li><code>node</code>: the DOM node where the event was triggered. For example, a <code>&lt;button&gt;</code>. If you use the same event handler on different nodes, this value will be different.</li>
<li><code>event</code>: The event object for the event.  If you&rsquo;re using <code>batman.jquery</code>, it&rsquo;s the jQuery event object. It contains meta-information about the event.</li>
<li><code>view</code>: The nearest <code>Batman.View</code> instance to <code>node</code>.</li>
</ul>


<h3>Combining Custom and Automatic Arguments</h3>

<p>You can combine custom and automatic arguments. Simply define a handler whose <strong>last three</strong> arguments are the batman.js automatic arguments:</p>

<p>```coffeescript
class MyApp.ItemsController extends MyApp.ApplicationContorller
  alertItemName: (item, punctuation, node, event, view) &ndash;></p>

<pre><code>itemName = item.get('name')
alert(itemName + punctuation)
</code></pre>

<p>```</p>

<p>And use <code>withArguments</code> to pass arguments to the function. You <strong>must</strong> pass the <strong>same number</strong> of arguments. For example:</p>

<p>```html</p>

<h1 data-bind='item.name'></h1>


<p><button data-event-click='alertItemName | withArguments item, "!"'>Alert!</button></p>

<!-- note the empty string, "" -->


<p><button data-event-click='alertItemName | withArguments item, ""'>Alert</button>
```</p>

<p>When batman.js passes arguments to the function, it simply merges the <code>withArguments</code> array with its automatic array. So, if your <code>withArguments</code> array is too short, you won&rsquo;t get the same results.</p>

<h2><code>@</code> in Event Handlers</h2>

<p>When batman.js dispatches an event handler, it looks up the base object <em>where that handler is defined</em>. Then, it uses that object as <code>@</code> inside the handler.</p>

<p>For example, consider two event handlers. One is defined on a view:</p>

<p>```coffeescript
class MyApp.ItemsIndexView extends Batman.View
  eventHandlerOne: &ndash;></p>

<pre><code>console.log(@) # =&gt; will be the ItemsIndexView instance
</code></pre>

<p>```</p>

<p>The other is defined on a controller:</p>

<p>```coffeescript
class MyApp.ItemsController extends App.ApplicationController
  eventHandlerTwo: &ndash;></p>

<pre><code>console.log(@) # =&gt; will be the ItemsController instance
</code></pre>

<p>```</p>

<p>If you were to hook up those event handlers to buttons:</p>

<p><code>html
&lt;button data-event-click='eventHandlerOne'&gt;&lt;/button&gt;
&lt;button data-event-click='eventHandlerTwo'&gt;&lt;/button&gt;
</code></p>

<p>then click the buttons, you would see the <code>ItemsIndexView</code> object and the <code>ItemsController</code> object in your console:</p>

<p><code>javascript
ItemsIndexView {bindings: Array[7], subviews: Set, _batman: _Batman, viewClass: function, source: "events/index"…}
ItemsController {redirect: function, handleError: function, errorHandler: function, _batman: _Batman, _actionFrames: Array[0]…}
</code></p>

<p>Since batman.js looks up the base object, event handlers behave just like normal functions in the place you define them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Batman.js and Devise]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/07/21/batman-dot-js-and-devise/"/>
    <updated>2014-07-21T09:08:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/07/21/batman-dot-js-and-devise</id>
    <content type="html"><![CDATA[<p>Using <a href="http://batmanjs.org">batman.js</a> with <a href="https://github.com/plataformatec/devise">Devise</a> is pretty straightforward.</p>

<!-- more -->


<p>It&rsquo;s also pretty cool-looking, because when you define <code>App.User.current</code>, all your view bindings are instantly updated to reflect the user&rsquo;s signed-in status!</p>

<p>You just have to consider three things:</p>

<ul>
<li>Make Devise communicate in JSON</li>
<li>Make batman.js send Devise-friendly requests</li>
<li>Keep your CSRF token up-to-date</li>
</ul>


<h2>Make Devise Communicate in JSON</h2>

<p>To make your Devise controllers accept and send JSON, register <code>:json</code> as a valid format. Do this by adding to <code>app/config/application.rb</code>:</p>

<p>```ruby</p>

<pre><code>config.to_prepare do
  DeviseController.respond_to :html, :json
end
</code></pre>

<p>```</p>

<p>(From a <a href="https://github.com/plataformatec/devise/issues/2209#issuecomment-12150223">comment on plataformatec/devise</a>)</p>

<p>Now, all the provided Devise controllers will accept the JSON format.</p>

<h2>Make Batman.js Send Devise-friendly Requests</h2>

<p>At time of writing (v0.16), the batman.js rails extra <em>only</em> sends the CSRF token with <code>Batman.RailsStorage</code> storage operations. So, all your requests will be &ldquo;disguised&rdquo; as storage operations.</p>

<p>(These samples include code for updating the CSRF token which is described in detail below)</p>

<h3>Signing In / Signing Up</h3>

<p>I made one form with two states: &ldquo;signing in&rdquo; or &ldquo;signing up&rdquo;. I initialized a User to bind to the form:</p>

<p>```coffeescript
class Funzies.SessionsController extends Funzies.ApplicationController
  new: &ndash;></p>

<pre><code>@set 'user', new Funzies.User
@dialog()
</code></pre>

<p>```</p>

<p>In the form, <code>actionName</code> was either &ldquo;Sign In&rdquo; or &ldquo;Create an Account&rdquo;:</p>

<p>```jade
.row
  .col-xs-12</p>

<pre><code>form data-event-submit='signIn'
  div.alert.alert-danger data-showif='user.errors.length'
    ul
      li data-foreach-e='user.errors' data-bind='e.fullMessage'
  .form-group
    label Email
    input.form-control type='text' data-bind='user.email'
  .form-group
    label Password
    input.form-control type='password' data-bind='user.password'
  .form-group data-showif='signingUp'
    label Password Confirmation
    input.form-control type='password' data-bind='user.password_confirmation'
  .form-group
    .row
      .col-sm-4
        input.btn.btn-primary type='submit' data-bind-value='actionName | append "!"'
      .col-sm-8
        a.pull-right data-event-click='signingUp | toggle' data-bind='otherActionName'
</code></pre>

<p>```</p>

<p><em>(the <code>toggle</code> filter will be released in Batman.js 0.17)</em></p>

<p>It turned out looking like this:</p>

<p><img src="/images/sign_in_form.png" width="500"> <img src="/images/sign_up_form.png" width="500"></p>

<p>Here&rsquo;s the handler for submitting that form. Notice that it handles <em>creating an account</em> and <em>signing up</em>. This might have been stupid of me.</p>

<p>Notice the bit about initializing a new User &mdash; it&rsquo;s because the <code>401</code> puts the user in &ldquo;error&rdquo; state (even with <code>@catchError</code>), which can&rsquo;t be cleared. This stinks and should be fixed in batman.js.</p>

<p>```coffeescript
  signIn: &ndash;></p>

<pre><code>url = if @get('signingUp')
    "/users.json"
  else
    "/users/sign_in.json"
@get('user').save {url}, (err, record, env) =&gt;
  if newToken = env?.data?.csrf_token
    @updateCSRFToken(newToken)
  if err?
    if err instanceof Batman.StorageAdapter.UnauthorizedError
      @set 'user', new Funzies.User(record.toJSON())
      @get('user.errors').add("base", "Email/password don't match our records!")
    else
      console.log(err)
    return
  else
    record.unset('password')
    record.unset('password_confirmation')
    Funzies.User.set('current', record)
    @closeDialog()
</code></pre>

<p>```</p>

<h3>Signing Out</h3>

<p>To send a <code>DELETE</code> request, we&rsquo;ll make a new user, then &ldquo;destroy&rdquo; it:</p>

<p>```coffeescript
  signOut: &ndash;></p>

<pre><code>user = new Funzies.User
user.url = "/users/sign_out.json"
user.destroy (err, record, env) =&gt;
  if newToken = env?.data?.csrf_token
    @updateCSRFToken(newToken)
  Funzies.User.unset('current')
</code></pre>

<p>```</p>

<p>Normally, destroying a not-yet-saved record throws an error. It doesn&rsquo;t throw an error in this case because the storage adapter doesn&rsquo;t check for presence of an ID. (Since we provide a URL, it doesn&rsquo;t need the ID for anything.)</p>

<h2>Keeping the CSRF Token Up-To-Date</h2>

<p>When Rails changes the session, it also provides a new CSRF token for that session. This means that when your user signs in our out, Rails will expect a new CSRF token in the requests from that user. So, make devise send <code>csrf_token</code> when a user signs in or out.</p>

<p>Add to your Devise routes:</p>

<p>```ruby
  devise_for :users, controllers: {</p>

<pre><code>sessions: "users/sessions", # for sending CSRF tokens
</code></pre>

<p>  }
```</p>

<p>Then define the <code>users/sessions</code> controller. Put this in <code>app/controllers/users/sessions_controller.rb</code>:</p>

<p>```ruby
class Users::SessionsController &lt; Devise::SessionsController
  respond_to :json</p>

<p>  def create</p>

<pre><code>resource = warden.authenticate!(
  :scope =&gt; resource_name,
  :recall =&gt; "#{controller_path}#failure"
  )
sign_in_and_redirect(resource_name, resource)
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>sign_out(resource_name)
# on sign-out, send back the CSRF token
render json: {csrf_token: form_authenticity_token}
</code></pre>

<p>  end</p>

<p>  private
  def sign_in_and_redirect(resource_or_scope, resource=nil)</p>

<pre><code>scope = Devise::Mapping.find_scope!(resource_or_scope)
resource ||= resource_or_scope
if warden.user(scope) != resource
  sign_in(scope, resource)
end
# on sign-in, put the CSRF token in the JSON!
return render json: current_user.as_json.merge({csrf_token: form_authenticity_token})
</code></pre>

<p>  end</p>

<p>  def failure</p>

<pre><code>return render :json =&gt; {:success =&gt; false, :errors =&gt; ["Login failed."]}
</code></pre>

<p>  end
end
```</p>

<p>Then, add a way for batman.js to update its <code>Batman.config.CSRF_TOKEN</code>. I put a function on my <code>SessionsController</code>:</p>

<p>```coffeescript
class Funzies.SessionsController
  updateCSRFToken: (token) &ndash;></p>

<pre><code>Batman.config.CSRF_TOKEN = token
</code></pre>

<p>```</p>

<p>That&rsquo;s what I use in <code>signIn</code> and <code>signOut</code> above.</p>
]]></content>
  </entry>
  
</feed>
