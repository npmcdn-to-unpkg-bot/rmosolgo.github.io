<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2015-08-04T10:46:12-07:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Move ActiveRecord Scopes into Separate Files]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/03/12/move-activerecord-scopes-into-separate-files/"/>
    <updated>2015-03-12T08:14:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/03/12/move-activerecord-scopes-into-separate-files</id>
    <content type="html"><![CDATA[<p>Ruby on Rails models tend to grow and grow. When refactoring scopes, it turns out you <em>can</em> move them into their own classes.</p>

<!-- more -->


<h2>The Problem</h2>

<p>Rails models can get out of hand. Over time they get more associations, more methods, more everything. The resulting huge API and visual clutter makes those classes hard to maintain.</p>

<p>Consider these scopes:</p>

<p>```ruby
class CheckIn &lt; ActiveRecord::Base
  scope :normal, &ndash;> { where(kind: &ldquo;Regular&rdquo;) }
  scope :guest, &ndash;> { where(kind: &ldquo;Guest&rdquo;) }
  scope :volunteer, &ndash;> { where(kind: &ldquo;Volunteer&rdquo;) }
  scope :first_time, &ndash;> {</p>

<pre><code>joins(%{
  INNER JOIN person_events
    ON  person_events.person_id =         check_ins.person_id
    AND person_events.event_id =          check_ins.event_id
    AND person_events.first_check_in_id = check_ins.id
    })
</code></pre>

<p>  }
end
```</p>

<h2>How do we usually address this?</h2>

<p>For me, refactoring often means finding related methods &amp; values that deserve their own class, then moving code out of the model and into the new class. For example:</p>

<ul>
<li>moving complex validations into <a href="http://api.rubyonrails.org/classes/ActiveModel/Validator.html">validator classes</a></li>
<li>moving complex serialization into serializer classes (I do this with serialization to <em>English</em>, too, not just JSON)</li>
<li>moving complex calculations into value classes.</li>
</ul>


<p>Whenever I&rsquo;m trying to move code out of a model, I visit Code Climate&rsquo;s <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">great post on the topic</a>.</p>

<p>However, <em>scopes</em> are never on the list. What can we do with those?</p>

<h2>Digging In</h2>

<p>I poked around Rails source a bit to see if there were any other options available to me.</p>

<p>I found that the <code>body</code> passed to <code>ActiveRecord::Base.scope</code> just has to <a href="https://github.com/rails/rails/blob/5e0b555b453ea2ca36986c111512627d806101e7/activerecord/lib/active_record/scoping/named.rb#L149">respond to <code>:call</code></a>. I guess that&rsquo;s why lambdas are a shoo-in for that purpose: they respond to <code>:call</code> and aren&rsquo;t picky about arguments.</p>

<p>The other thing I found is that the lambdas you usually pass to <code>scope</code> <em>aren&rsquo;t magical</em>. I always assumed that they were <code>instance_eval</code>&rsquo;d against other objects at whatever other times, but as far as I can tell, they aren&rsquo;t magical. <code>self</code> is always the model class (from lexical scope), just like any other lambda.</p>

<p>Instead, the magic is a combination of Rails' <a href="https://github.com/rails/rails/blob/5e0b555b453ea2ca36986c111512627d806101e7/activerecord/lib/active_record/scoping.rb#L57">thread-aware <code>ScopeRegistry</code></a> which tracks the scope for a given class, combined with <a href="https://github.com/rails/rails/blob/ce32ff462f3ba89c87f337f9150b3976d23220e8/activerecord/lib/active_record/relation.rb#L319"><code>Association#scoping</code></a>, which I don&rsquo;t understand. :)</p>

<h2>Moving Scopes from Lambda to Class</h2>

<p>You can make a class that complies to the required API. Make calls on the model class (<code>CheckIn</code>, in my case), which is usually <code>self</code> in a <code>scope</code> lambda.</p>

<p>```ruby</p>

<h1>app/models/check_in/scopes/latest.rb</h1>

<p>class CheckIn::Scopes::Latest
  def call</p>

<pre><code>CheckIn.where("check_ins.id IN (SELECT max(id) FROM check_ins GROUP BY check_ins.person_id)")
</code></pre>

<p>  end
end
```</p>

<p>Then, hook up the scope in the model definition:</p>

<p><code>ruby
class CheckIn &lt; ActiveRecord::Base
  scope :latest, Scopes::Latest.new
end
</code></p>

<p>Since it&rsquo;s just a plain ol' class, you can give it <strong>other methods</strong> too:</p>

<p>```ruby</p>

<h1>app/models/check_in/scopes/latest.rb</h1>

<p>class CheckIn::Scopes::Latest
  def call</p>

<pre><code>CheckIn.where(query_string)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def query_string</p>

<pre><code>"check_ins.id IN (SELECT max(id) FROM check_ins GROUP BY check_ins.person_id)"
</code></pre>

<p>  end
end
```</p>

<p>You can also <strong>initialize it</strong> with some data:</p>

<p><code>ruby
class CheckIn &lt; ActiveRecord::Base
  scope :normal,          Scopes::KindScope.new("Regular")
  scope :guest,           Scopes::KindScope.new("Guest")
  scope :volunteer,       Scopes::KindScope.new("Volunteer")
end
</code></p>

<h2>Any Benefit?</h2>

<p>Here&rsquo;s what I think:</p>

<p><strong>Pros:</strong></p>

<ul>
<li>Less visual noise.</li>
<li>Your model still reads like a table of contents.</li>
<li>Theoretically, you could test the scope in isolation (but I&rsquo;m too lazy, if the existing tests still pass, that&rsquo;s good enough for me :P).</li>
</ul>


<p><strong>Cons:</strong></p>

<ul>
<li>If the scope takes arguments, you can&rsquo;t tell right away.</li>
<li>It doesn&rsquo;t <em>actually</em> shrink the class&rsquo;s API: it&rsquo;s still a big ol' model.</li>
<li>It&rsquo;s not a known Rails practice.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy Refactoring by Keeping ApplicationController to a Minimum]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/01/17/happy-refactoring-by-keeping-applicationcontroller-to-a-minimum/"/>
    <updated>2015-01-17T10:24:00-08:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/01/17/happy-refactoring-by-keeping-applicationcontroller-to-a-minimum</id>
    <content type="html"><![CDATA[<p>Extending <code>ActionController::Base</code> <em>once</em>, in <code>ApplicationController</code>, is a great Ruby on Rails practice. However, if <code>ApplicationController</code> is your only abstract controller, it&rsquo;s likely to become a maintenance challenge. To avoid this, you should extend <code>ApplicationController</code> as needed and move as much code as possible into its subclasses.</p>

<!-- more -->


<h2>Feeling ApplicationController Pain</h2>

<p>So, our app is live. We&rsquo;ve dutily extended <code>ApplicationController</code> in all our other controllers, giving us an inheritance tree like this:</p>

<p><img src="/images/controller_inheritance_bad.png" width="500" height="500"></p>

<p>Fortunately, our app is a success and our customers want us to open an API. Let&rsquo;s use <code>API::BaseController</code> as the superclass of all our API controllers:</p>

<p><img src="/images/controller_inheritance_bad_with_api.png" width="500" height="500"></p>

<p>As our user base grows, we need a more robust permissions system. We tighten up restrictions:</p>

<p><code>ruby
class ApplicationController &lt; ActionController::Base
  before_action :authenticate!
end
</code></p>

<p>Since some actions are public, we skip the restrictions:</p>

<p>```ruby
class ReportsController &lt; ApplicationController
  skip_before_action :authenticate!
end</p>

<h1>&hellip;</h1>

<p>class ProfilesController &lt; ApplicationController
  skip_before_action :authenticate!
end
```</p>

<p>We&rsquo;ve forgotten about our API, and when we deploy, we&rsquo;ll be quickly reminded that <code>ApplicationController</code> is involved in those requests too. Since <code>ApplicationController</code> touches <em>every request</em>, it&rsquo;s hard to be sure about exactly what will be affected by changes there.</p>

<h2>ApplicationController Gains Weight</h2>

<p>Left alone, <code>ApplicationController</code> can bloat for many reasons:</p>

<ul>
<li><strong>Authentication logic</strong>, perhaps with complex branching based on what the user is accessing, builds up little-by-little as the application is extended.</li>
<li><strong>Before-actions &amp; helpers</strong> which are used <em>often</em> but <em>not always</em> tend to accrue in <code>ApplicationController</code>, since they&rsquo;re &ldquo;used more than once.&rdquo;</li>
<li><strong>Oddball routes</strong> might be implemented in <code>ApplicationController</code> because no other existing controller seems like the right place.</li>
</ul>


<p>In JavaScript development, filling the global namespace with application code is a no-no. Similarly, <code>ApplicationController</code> is a near-global namespace, so each addition to it should be considered very carefully. When we add to (and remove from) <code>ApplicationController</code>, we&rsquo;re potentially altering <em>every</em> request that our application serves; how can we be sure we aren&rsquo;t breaking something?</p>

<h2>Isolating &ldquo;Parts&rdquo; of the App</h2>

<p>Returning to the example above, I think this inheritance tree is better:</p>

<p><img src="/images/controller_inheritance_good.png" width="500" height="500"></p>

<p>We&rsquo;ve introduced abstract classes for each &ldquo;part&rdquo; of the app. (I use quotes because I don&rsquo;t know a technical term for it!) Now, logged-in authentication would be handled by a subclass of <code>ApplicationController</code>, perhaps named <code>BaseController</code>. A logged-in controller would extend <code>BaseController</code>. For example:</p>

<p><code>ruby
class ItemsController &lt; BaseController
  # ...
end
</code></p>

<p>Similarly, public controllers would be in a namespace of their own, with their own base controller. For example:</p>

<p><code>ruby
class Public::ProfilesController &lt; Public::BaseController
  # ...
end
</code></p>

<p>This is good because:</p>

<ul>
<li>You can refactor with more confidence, since you only have to load <em>part</em> of the app into memory when working on abstract controllers.</li>
<li>Stable parts of the app are more likely to remain stable (since they won&rsquo;t be affected by other parts).</li>
</ul>


<p>The corresponding file structure looks like this:</p>

<p>```bash
controllers/
  api/</p>

<pre><code>base_controller.rb
items_controller.rb
profiles_controller.rb
</code></pre>

<p>  public/</p>

<pre><code>base_controller.rb
reports_controller.rb
profiles_controller.rb
</code></pre>

<p>  staff/</p>

<pre><code>base_controller.rb
stats_controller.rb
</code></pre>

<p>  application_controller.rb
  base_controller.rb
  items_controller.rb
  profiles_controller.rb
  reports_controller.rb
```</p>

<p><em>(I&rsquo;ve left some controllers in the root namespace. If you like, you could put logged-in actions in a namespace too!)</em></p>

<p>And the routes might look like this:</p>

<p>```ruby
namespace :api do
  resources :items, :profiles
end</p>

<p>namespace :public do
  resources :profiles, :reports
end</p>

<p>namespace :staff do
  resources :stats
end</p>

<p>resources :items, :profiles, :reports
```</p>

<h2>When should we extend ApplicationController?</h2>

<p>I&rsquo;d say it&rsquo;s good to extend <code>ApplicationController</code> for each &ldquo;part&rdquo; of the app. It&rsquo;s a bit subjective, but here are some clues:</p>

<ul>
<li>Actions rendered with a <strong>different layout</strong> (or lack thereof). Your webservice, administration and public views are distinct parts of your app.</li>
<li>Actions using <strong>different authentication</strong> strategies. Keep API endpoints, public pages, and staff-only actions in separate sections. If a staff member goes rogue, you&rsquo;ll be able to tighten up that part of the app confidently :)</li>
<li>Actions with <strong>different frequently-used helpers or before-actions</strong>. If there&rsquo;s a before-action that&rsquo;s often skipped, Rails wants to tell you something: these controllers are different! Similarly, if you have controller-level helper methods, perhaps the controllers who depend on that helper should be in a &ldquo;part&rdquo; of their own.</li>
</ul>


<p>I hope a pattern like this will give you more freedom &amp; confidence when refactoring important parts of the request-response cycle!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamically-Generated Headers for ActiveResource Requests]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/02/05/dynamically-generated-headers-for-activeresource-requests/"/>
    <updated>2014-02-05T15:47:00-08:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/02/05/dynamically-generated-headers-for-activeresource-requests</id>
    <content type="html"><![CDATA[<p>Need to add a header to an ActiveResource request? If you need to do it at dynamically at request-time, redefine <code>.headers</code>.</p>

<!-- more -->


<p>I needed to include header in my requests, but I didn&rsquo;t just want to set it in the class definition.</p>

<p><code>ruby
class MyResource &lt; ActiveResource::Base
  headers["My-Header"] = "Something-Useful" # boo hiss, I want it dynamically!
end
</code></p>

<p>So, I overwrote <code>.headers</code> to be a method rather than just a pointer to a hash:</p>

<p>```ruby
class MyResource &lt; ActiveResource::Base
  cattr_accessor :static_headers
  self.static_headers = headers</p>

<p>  def self.headers</p>

<pre><code>new_headers = static_headers.clone
new_headers["My-header"] = MyClass.some_method # voila, evaluated at request-time
new_headers
</code></pre>

<p>  end
end
```</p>

<p>Now, I can add whatever value to the headers I want, whenever I want!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Batman.js testing with Karma and Jasmine]]></title>
    <link href="http://rmosolgo.github.io/blog/2014/01/18/batman-dot-js-testing-with-karma-and-jasmine/"/>
    <updated>2014-01-18T14:38:00-08:00</updated>
    <id>http://rmosolgo.github.io/blog/2014/01/18/batman-dot-js-testing-with-karma-and-jasmine</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s how I set up <a href="http://karma-runner.github.io/">Karma</a> &amp; <a href="http://pivotal.github.io/jasmine/">Jasmine</a> to test a <a href="http://batmanjs.org/">Batman.js</a> app on Ruby on Rails.</p>

<!-- more -->


<p>(Actually, this is how we use it at <a href="http://get.planningcenteronline.com/">work</a>. Credit to <a href="http://danott.co/">Dan</a>, as this is modeled after his work and <a href="http://danott.co/posts/rails-javascript-testing-using-karma.html">blog post</a>)</p>

<p><em>Warning:</em> This is a bit hack-ish because it depends on your development server running while you run your tests. :)</p>

<h1>Set Up Karma</h1>

<p>You&rsquo;ll need <a href="http://nodejs.org/"><code>node</code></a> and <a href="https://npmjs.org/"><code>npm</code></a> for this to work! Create the directory <code>/spec/karma</code> and put these files in it:</p>

<ul>
<li><code>package.json</code>, which will tell <code>npm</code> what to install for you:</li>
</ul>


<p>```json spec/karma/package.json
{
  &ldquo;name&rdquo;: &ldquo;your-app-name&rdquo;,
  &ldquo;version&rdquo;: &ldquo;0.0.1&rdquo;,
  &ldquo;engines&rdquo;: {</p>

<pre><code>"node": "&gt;= 0.10"
</code></pre>

<p>  },
  &ldquo;dependencies&rdquo;: {</p>

<pre><code>"karma": "&gt;= 0.10",
"karma-chrome-launcher": "~0.1",
"karma-coffee-preprocessor": "~0.1",
"karma-jasmine": "~0.2"
</code></pre>

<p>  },
  &ldquo;devDependencies&rdquo;: {</p>

<pre><code>"coffee-script": "^1.7.1"
</code></pre>

<p>  }
}
```</p>

<ul>
<li><code>unit.coffee</code>, the configs for Karma:</li>
</ul>


<p>```coffeescript spec/karma/unit.coffee
module.exports = (config) &ndash;>
  config.set</p>

<pre><code>basePath: '../../'
frameworks: ['jasmine'] # that's my weapon of choice, anyways.
plugins: [
  'karma-coffee-preprocessor'
  'karma-chrome-launcher'
  'karma-jasmine'
]
preprocessors: {
  'spec/batman/**/*.coffee': ['coffee']
}
files: [
  'http://your-app.dev/assets/your-app.js' # point it at the app file on your dev server
  # yours might look like 'http://localhost:3000/assets/application.js' or something like that.
  # Of course, you can list as many files as you want here.
  'spec/batman/**/*.coffee' # load your tests
]
reporters: ['dots']
port: 9876
colors: true
logLevel: config.LOG_INFO
autoWatch: true
browsers: ['Chrome']
captureTimeout: 60000
singleRun: false
</code></pre>

<p>```</p>

<ul>
<li><code>run</code>, a bash script to start the runner easily:</li>
</ul>


<p>```bash spec/karma/run</p>

<h1>!/bin/bash</h1>

<p>BASE_DIR=<code>dirname $0</code>
$BASE_DIR/node_modules/karma/bin/karma start $BASE_DIR/unit.coffee</p>

<h1>from app root, just run <code>$ ./karma/run</code> to start the tests!</h1>

<p>```</p>

<ul>
<li>Make <code>run</code> executable with <code>$ chmod +x spec/karma/run</code>.</li>
<li>Add <code>spec/karma/node_modules</code> to <code>.gitignore</code> so you&rsquo;re not pushing around tons of Node modules with your project.</li>
<li>Install Karma locally with <code>npm install spec/karma</code>.</li>
</ul>


<p>You should be able to start the runner now with <code>$ spec/karma/run</code>. It will open a Chrome window if it&rsquo;s working.</p>

<h1>Write a Spec</h1>

<p>I put my Batman.js specs in <code>spec/batman</code> with names corresponding to their location in <code>app/assets/batman</code>. You can do it however you want, but make sure you&rsquo;re loading the right files with <code>files</code> in <code>unit.coffee</code> above. Open up your first spec file, maybe <code>spec/batman/test_spec.coffee</code>, and put a jasmine spec in it:</p>

<p>```coffeescript spec/batman/test_spec.coffee
describe &lsquo;My test runner&rsquo;, &ndash;>
  it &lsquo;loaded Batman.js&rsquo;, &ndash;></p>

<pre><code>expect(Batman).toBeDefined()
</code></pre>

<p>  it &lsquo;loaded my App&rsquo;, &ndash;></p>

<pre><code>expect(App).toBeDefined() # &lt;-- your app name!
</code></pre>

<p>  it &lsquo;loaded my Model&rsquo;, &ndash;></p>

<pre><code>expect(App.Model).toBeDefined() # &lt;-- your model name!
</code></pre>

<p>```
If those pass, you&rsquo;re in business!</p>

<h1>Using Batman.TestCase</h1>

<p>Since <code>Batman.TestCase</code> is a Batman extra, you&rsquo;ll need to include it in your project yourself. An easy way to do that is to include the <a href="https://github.com/batmanjs/batman/tree/master/src/extras"><code>src/extras/</code> directory</a> from Github in your Rails app. For example, in <code>/app/assets/batman/extras</code>. Now, in your development server, visit <code>/assets/extras/batman.test_case.js</code>. Do you see the code for <code>Batman.TestCase</code>?</p>

<p>Now, just add that path to <code>files</code> in <code>spec/karma/unit.coffee</code>:</p>

<p>```coffeescript spec/karma/unit.coffee</p>

<h1>&hellip;</h1>

<p>  files: [</p>

<pre><code>"http://my-app.dev/assets/my_app.js"
"http://my-app.dev/assets/extras/batman.test_case.js"
"spec/batman/**/*.coffee"
</code></pre>

<p>  ]</p>

<h1>&hellip;</h1>

<p>```</p>

<p>And if you want, make sure it&rsquo;s loaded with a jasmine spec:</p>

<p>```coffeescript spec/batman/test_case_spec.coffee
describe &ldquo;Batman.TestCase is loaded&rdquo;, &ndash;>
  it &ldquo;is defined&rdquo;, &ndash;></p>

<pre><code>expect(Batman.TestCase).toBeDefined()
</code></pre>

<p>```</p>

<h1>Not working?</h1>

<ul>
<li>Did you make <code>run</code> executable by with <code>$ chmod +x spec/karma/run</code>?</li>
<li>This is kind of a hacky setup &mdash; it depends on your development server (either <code>$ rails server</code> or <a href="http://pow.cx/">Pow</a>) running. Is it?</li>
<li>In <code>unit.coffee</code>, <code>files</code> should list your tests, but it should also list compiled JS assets from your development server, including <code>http://</code> and so on. Check the paths there in your browser. Do they contain everything you expect them to contain? You might need to add files to that list <em>or</em> add <a href="https://github.com/sstephenson/sprockets">sprockets</a> directives to those files so that they <code>require</code> other files.</li>
</ul>


<p>Ok, well it ain&rsquo;t perfect but it works. Hope it helps!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Slim Templates with Batman.js and the Rails Asset Pipeline]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/11/25/slim-templates-with-batmanjs-and-the-rails-asset-pipeline/"/>
    <updated>2013-11-25T13:28:00-08:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/11/25/slim-templates-with-batmanjs-and-the-rails-asset-pipeline</id>
    <content type="html"><![CDATA[<p>You can use <a href="http://slim-lang.com/">Slim</a> (or Haml) to serve your <a href="http://batmanjs.org">Batman.js</a> templates in the Rails Asset Pipeline.</p>

<!-- more -->


<h1>1. Include Slim in your gemfile</h1>

<p>Add this line to your <code>Gemfile</code>:</p>

<p><code>ruby Gemfile
gem "slim"
</code></p>

<h1>2. Register the Slim engine with Rails</h1>

<p>Make a new initializer (eg, <code>config/initializers/slim_assets.rb</code>) and put this in it:</p>

<p><code>ruby config/initializers/slim_assets.rb
Rails.application.assets.register_engine('.slim', Slim::Template)
</code></p>

<p>Credit: <a href="http://www.dillonbuchanan.com/programming/rails-slim-templates-in-the-asset-pipeline/">Dillon Buchanan</a></p>

<h3>Update: Serving compiled Slim (or Haml) assets in production</h3>

<p>When you deploy to production, if you have <code>config.initialize_on_precompile = false</code>, an initializer isn&rsquo;t going to work. You&rsquo;ll have to register the Sprockets engine another way. Add it to the application config in <code>config/application.rb</code>:</p>

<p>```ruby config/application.rb
module MyApp
  class Application &lt; Rails::Application</p>

<pre><code># ... config stuff ...
config.before_initialize do |app|
  require 'sprockets'
  require 'slim'
  # require 'tilt' # for Haml
  Sprockets::Engines #force autoloading
  Sprockets.register_engine '.slim', Slim::Template
  # Sprockets.register_engine '.haml', Tilt::HamlTemplate # for Haml
end
# ... more config stuff ...
</code></pre>

<p>  end
end
```</p>

<p>Now, you&rsquo;ll have the Slim template engine available even if your app doesn&rsquo;t intialize, which is most notably the case for <code>bundle exec rake assets:precompile</code>. Nice!</p>

<h1>3. Beef up your BatmanController</h1>

<p>At time of writing, the <code>batman-rails</code>-generated BatmanController won&rsquo;t work right in production. There&rsquo;s an <a href="https://github.com/batmanjs/batman-rails/pull/46">outstanding PR</a> with a fix. If that&rsquo;s closed, then we&rsquo;re good to go. In the mean time, Make your <code>app/controllers/batman_controller.rb</code> look like this:</p>

<p>```ruby app/controllers/batman_controller.rb
class BatmanController &lt; ApplicationController
  def index</p>

<pre><code>if request.xhr?
  prefix_length = Rails.application.config.assets.prefix.length + 1
  path = request.path[prefix_length..-1]
  render :text =&gt; Rails.application.assets[path]
else
  render nothing: true, layout: 'batman'
end
</code></pre>

<p>  end
end
```</p>

<p>When this is done, any files ending in <code>.html.slim</code> in <code>assets</code> will be served as rendered HTML in response to XHR (Ajax) requests. Note that <em>all non-XHR</em> requests will still receive the <code>batman</code> layout (but then Batman will respond to the request, so you&rsquo;re all good).</p>
]]></content>
  </entry>
  
</feed>
