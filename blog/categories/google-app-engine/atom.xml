<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google App Engine | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/google-app-engine/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2015-03-12T09:11:56-07:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lessons Learned on Google App Engine]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/11/01/lessons-learned-on-google-app-engine/"/>
    <updated>2013-11-01T13:00:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/11/01/lessons-learned-on-google-app-engine</id>
    <content type="html"><![CDATA[<p>My involvement with a <a href="https://cloud.google.com/products/app-engine">Google App Engine</a>-based project is winding down, so I&rsquo;ll share what I&rsquo;ve learned.</p>

<!-- more -->


<h1>Building for App Engine is tough</h1>

<p>If you&rsquo;re thinking about starting a project on GAE, think about it carefully. I had a hard time with it for several reasons, but my first mistake was thinking, &ldquo;Oh, this will be a way to get an app going quickly and cheaply without all that sysadmin trouble.&rdquo; This is not the case for a few reason:</p>

<ul>
<li>mission-critical features depend on <em>GAE-specific</em> APIs which are often poorly documented and not very googlable.</li>
<li>you&rsquo;ll be learning a <a href="https://developers.google.com/appengine/docs/python/ndb/">new database (NDB)</a>, a <a href="https://developers.google.com/appengine/docs/python/memcache/">new memcache server</a> and a <a href="https://developers.google.com/appengine/docs/python/taskqueue/">new task queuer</a>, among others.</li>
<li>GAE support for Django is so-so. You&rsquo;ll probably have to learn a new framework. Make sure to use <a href="http://webapp-improved.appspot.com/">WebApp2</a> if you&rsquo;re trying to set up a lightweight application.</li>
</ul>


<p>If you want quick, cheap prototyping, consider <a href="http://heroku.com/">Heroku</a> instead. You&rsquo;ll have access to all the standard components of the modern web stack (rather than GAE-specific ones) and Heroku supports <a href="https://devcenter.heroku.com/categories/language-support">many languages</a>.</p>

<h1>Development server != Production server</h1>

<p>The development environment differs from the production environment in several ways. The ones I found are:</p>

<ul>
<li>No memory limit on the development server</li>
<li>No timeouts on the development server</li>
<li>Asynchronous features don&rsquo;t work on the development server (futures don&rsquo;t resolve until they&rsquo;re explicitly waited for)</li>
</ul>


<p>So, something that works in development may not work in production! (And apparently the same is <a href="https://developers.google.com/appengine/docs/python/tools/localunittesting#Python_Introducing_the_Python_testing_utilities">true for the test stubs</a>.)</p>

<h1>You might have to pay for your staging environment</h1>

<p>Unless you look into <a href="http://www.appscale.com/">AppScale</a> (I didn&rsquo;t), you&rsquo;ll need another GAE instance for your staging server. Unless you pay, you won&rsquo;t be able to test rigorous features of the app.</p>

<h1>The Datastore has some drawbacks</h1>

<ol>
<li><p>You pay to use it. If your application will be database-intensive (reads, writes and/or deletes), it&rsquo;s gonna cost you. It adds up &mdash; make sure to set a nice low cap on your budget.</p></li>
<li><p>The pricing is non-intuitive at first. You&rsquo;re charged for each value in the stored entity, its key, and each value in any indexes that entity has.</p></li>
<li><p>Indexes are expensive to maintain (because of the point above). Remove ones you don&rsquo;t desperately need!</p></li>
<li><p>It&rsquo;s an unfamiliar, low-level API. To me, anyways &mdash; it&rsquo;s no ActiveRecord.</p></li>
</ol>


<h1>Don&rsquo;t cache if you&rsquo;re running big queries</h1>

<p>Make sure to pass the <a href="https://developers.google.com/appengine/docs/python/ndb/functions#context_options"><code>use_cache=false</code> context option</a> or else it will kill your instance for memory overload! For example:</p>

<p><code>python
  some_big_query = AppModel.query(AppModel.some_property == value)
  lots_of_items = some_big_query.fetch(use_cache=False) # otherwise it will cache entities in memory
</code></p>

<p>Also, consider the <a href="https://developers.google.com/appengine/docs/python/ndb/queryclass#kwdargs_options"><code>keys_only</code> option</a> if you&rsquo;re performing actions that could work with just the keys. <a href="https://developers.google.com/appengine/docs/python/ndb/keyclass#Key_delete">Deleting</a>, for example:</p>

<p><code>python
  unwanted_entity_keys = AppModel.query(AppModel.some_property == value).fetch(keys_only=True)
  ndb.delete_multi(unwanted_entity_keys)
</code></p>

<h1>Use pages to run big queries</h1>

<p>Datastore operations are limited to 60 seconds, even on the backend. If you&rsquo;re iterating over lots of entities and/or performing time-consuming tasks on each one, you&rsquo;ll want to use the <a href="https://developers.google.com/appengine/docs/python/ndb/queryclass#Query_fetch_page"><code>Query#fetch_page</code></a> method. For example, creating a CSV based on a query:</p>

<p>```python
class AppModel(ndb.model):
  CSV_HEADER = &ldquo;heading,heading,heading\n&rdquo;
  @class_method
  def csv_by_dates(cls, start_date, end_date):</p>

<pre><code>PAGE_SIZE = 500 # I'll process 500 at a time
csv = cls.CSV_HEADER

# here's a big query:
query = cls.query(cls.date &gt; start_date, cls.date &lt; end_date).order(cls.date)
# use the fetch_page method:
results, cursor, more = query.fetch_page(PAGE_SIZE, use_cache=False)

while len(results) &gt; 0:
  for d in results:
    csv += d.to_csv() # load up the CSV
  # pass `cursor` to the next query:
  results, cursor, more = query.fetch_page(PAGE_SIZE, start_cursor=cursor, use_cache=False)

return csv
</code></pre>

<p>  # def to_csv(self): &hellip;
```</p>

<p><em>Ok, that&rsquo;s all for now!</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Command-Line Tools for Backends on Google App Engine]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/08/07/backends-on-google-app-engine/"/>
    <updated>2013-08-07T19:17:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/08/07/backends-on-google-app-engine</id>
    <content type="html"><![CDATA[<p>It took me quite a while to realize that my <a href="https://cloud.google.com/products/app-engine">GAE</a> <a href="https://developers.google.com/appengine/docs/python/backends/">backend</a> wasn&rsquo;t working because I had to use <a href="https://developers.google.com/appengine/docs/python/gettingstartedpython27/uploading">appcfg</a>, not the <a href="https://developers.google.com/appengine/downloads">App Engine Launcher</a> to deploy it. App Engine Launcher&rsquo;s &ldquo;deploy&rdquo; button wouldn&rsquo;t do it.</p>

<!-- more -->


<p>Looks like I wasn&rsquo;t the only one who took a while to figure it out:</p>

<p>{% blockquote Brett Cannon, Coder Who Says Py <a href="http://sayspy.blogspot.com/2012/01/working-with-app-engine-backends.html">http://sayspy.blogspot.com/2012/01/working-with-app-engine-backends.html</a> &ldquo;Working with App Engine Backends&rdquo; %}
[Y]ou can&rsquo;t use the &hellip; AppEngineLauncher to use backends. So if you want to use backends &hellip; you will need to use the command-line version of the tools. Obviously this is a minor thing, but it took me quite a while to realize that was why backends were not working for me.
{% endblockquote %}</p>

<p>(and this guy used to work for Google &hellip; <em>on the App Engine team!</em>) Anyways, now I&rsquo;m straightened out:</p>

<p>{% codeblock %}</p>

<p>$ appcfg backends ./ update datacrawler</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable filesystem writes in GAE dev_appserver]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/08/05/enable-filesystem-writes-in-gae-dev-appserver/"/>
    <updated>2013-08-05T20:43:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/08/05/enable-filesystem-writes-in-gae-dev-appserver</id>
    <content type="html"><![CDATA[<p><a href="https://cloud.google.com/products/">Google App Engine</a>&rsquo;s <code>dev_appserver</code> prevents filesystem writes because GAE has no filesystem &mdash; but sometimes you want to write anyways!</p>

<!-- more -->


<p>I was working over a big set of data from the <a href="https://developers.google.com/appengine/docs/python/storage#App_Engine_Datastore">Google App Engine High-Replication Datastore</a> and I found that, somewhere in my loop, memory was slipping away&hellip;</p>

<p>So I got <a href="http://mg.pov.lt/objgraph/">objgraph</a>, which creates a graphic based on your memory usage. But I had a problem: Google App Engine doesn&rsquo;t have a filesystem, so the development server prevents you from writing to files. <code>objgraph</code> couldn&rsquo;t create my graphic!</p>

<p>Luckily, the fix was simple: I found the line that threw the error and commented it out. <em>(The file is <code>[your_appengine_root]\google\appengine\tools\devappserver2\python\stubs.py</code>)</em></p>

<p>{% codeblock stubs.py lang:python  %}
  # Starting on line 242:
  def <strong>init</strong>(self, filename, mode=&lsquo;r&rsquo;, bufsize=-1, **kwargs):</p>

<pre><code>"""Initializer. See file built-in documentation."""
# if mode not in FakeFile.ALLOWED_MODES:
#   raise IOError(errno.EROFS, 'Read-only file system', filename)

if not FakeFile.is_file_accessible(filename):
  raise IOError(errno.EACCES, 'file not accessible', filename)

super(FakeFile, self).__init__(filename, mode, bufsize, **kwargs)
</code></pre>

<p>{% endcodeblock %}</p>

<p>By the way, it didn&rsquo;t turn out to be a memory leak. It was <a href="https://developers.google.com/appengine/docs/python/ndb/cache">GAE&rsquo;s NDB caching</a> in action &mdash; I just disabled it by:
{% codeblock lang:python %}
for d_key in query.iter(keys_only=true):
  d = d_key.get(use_cache=False, use_memcache=False)
  # &hellip;
  d.put(use_cache=False, use_memcache=False)
{% endcodeblock %}</p>

<p>Then I was all clear!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serving static files in WebApp2 reponses]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/08/04/serving-static-files-in-webapp2-responses/"/>
    <updated>2013-08-04T19:22:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/08/04/serving-static-files-in-webapp2-responses</id>
    <content type="html"><![CDATA[<p>On <a href="https://cloud.google.com/products/">Google App Engine</a>, I had to display the user-submitted image, if there was one, else display a default image.</p>

<!-- more -->


<p>The given object could only have one image, so I was using the <a href="https://developers.google.com/appengine/docs/python/ndb/properties">NDB BlobProperty</a>:</p>

<p>{% codeblock lang:python %}
class Sensor(ndb.Model):
  image = ndb.BlobProperty()
{% endcodeblock %}</p>

<p>I put the default image in my application root (alongside <code>app.yaml</code>):</p>

<p>{% codeblock lang:yaml %}
app_root:
  request_handlers:</p>

<pre><code>- __init__.py
- handlers.py
</code></pre>

<ul>
<li>app.yaml</li>
<li>default_sensor.jpg
&hellip;
{% endcodeblock %}</li>
</ul>


<p>In my request handler, I checked for the presence of an image, and gave the default image if there wasn&rsquo;t one there:</p>

<p>{% codeblock lang:python %}</p>

<h1>responds to &ldquo;/sensors/(\w+)/image&rdquo;</h1>

<p>class SensorImage(webapp2.RequestHandler):
  DEFAULT_IMAGE = &lsquo;default_sensor.jpg&rsquo;
  def get(self, hex):</p>

<pre><code>r = self.response
r.headers['Content-Type'] = "image/jpg"
this_sensor = Sensor.find_by_hex(hex)

if (not this_sensor) or (not this_sensor.image):

  image = open(SensorImage.DEFAULT_IMAGE, 'rb')
  r.body_file.write( image.read() )
  image.close()

else:
  r.body_file.write( this_sensor.image )
</code></pre>

<p>{% endcodeblock %}</p>

<p>That way, I had one URL that didn&rsquo;t change whether a user uploaded an image or not.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling Files in WebApp2 and Google App Engine]]></title>
    <link href="http://rmosolgo.github.io/blog/2013/08/04/handling-files-in-webapp2-and-google-app-engine/"/>
    <updated>2013-08-04T19:22:00-07:00</updated>
    <id>http://rmosolgo.github.io/blog/2013/08/04/handling-files-in-webapp2-and-google-app-engine</id>
    <content type="html"><![CDATA[<p>On <a href="https://cloud.google.com/products/">Google App Engine</a>, I had to display the user-submitted image, if there was one, else display a default image. The given object could only have on image, so I was using the <a href="https://developers.google.com/appengine/docs/python/ndb/properties">NDB BlobProperty</a>:</p>

<!-- more -->


<p>{% codeblock lang:python %}
class Sensor(ndb.Model):
  image = ndb.BlobProperty()
{% endcodeblock %}</p>

<p>I put the default image in my application root (alongside <code>app.yaml</code>):</p>

<p>{% codeblock lang:yaml %}
app_root:
  request_handlers:</p>

<pre><code>- __init__.py
- handlers.py
</code></pre>

<ul>
<li>app.yaml</li>
<li>default_sensor.jpg
{% endcodeblock %}</li>
</ul>


<p>In my request handler, I checked for the presence of an image, and gave the default image if there wasn&rsquo;t one there:</p>

<p>{% codeblock lang:python %}</p>

<h1>responds to &ldquo;/sensors/(\w+)/image&rdquo;</h1>

<p>class SensorImage(webapp2.RequestHandler):
  DEFAULT_IMAGE = &lsquo;default_sensor.jpg&rsquo;
  def get(self, hex):</p>

<pre><code>r = self.response
r.headers['Content-Type'] = "image/jpg"
this_sensor = Sensor.find_by_hex(hex)

if (not this_sensor) or (not this_sensor.image):

  image = open(SensorImage.DEFAULT_IMAGE, 'rb')
  r.body_file.write( image.read() )
  image.close()

else:
  r.body_file.write( this_sensor.image )
</code></pre>

<p>{% endcodeblock %}</p>

<p>That way, I had one URL that didn&rsquo;t change whether a user uploaded an image or not.</p>
]]></content>
  </entry>
  
</feed>
